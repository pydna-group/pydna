from itertools import cycle

class CircularBytes(bytes):
    def __getitem__(self, key):
        """
        Overrides the bytes.__getitem__ method to add circular indexing and slicing.
        """
        if isinstance(key, int):  # Single index
            index = key % len(self)  # Circular adjustment
            return bytes((super().__getitem__(index),))
        elif isinstance(key, slice):  # Slicing
            start, stop, step = key.indices(len(self)*2)
            shifted = super().__getitem__(slice(start, None)) + super().__getitem__(slice(None, start))
            if start > stop:
                return shifted[start-stop:]
            elif start == stop:
                return shifted
            return (shifted*2)[:stop]
        else:
            raise TypeError("Invalid argument type. Key must be int or slice.")

    def __repr__(self):
        """
        Representation of the CircularBytes object.
        """
        return f"CircularBytes({super().__repr__()})"


# Example Usage
if __name__ == "__main__":
    cb = CircularBytes(b"GGTACCa")
    # print(cb[1])            # Output: 50 (ASCII code of '2')
    # print(cb[1:1])          # Output: b'231' (special case, rearranged starting from index 1)
    # print(cb[-1:])          # Output: b'3' (normal slicing)
    # print(cb[5])            # Output: 49 (ASCII code of '1', wraps around)
    # print(cb[:8])           # Output: b'12312312' (wraps around for slicing)
    # print(cb[-3:10:2])      # Output: b'131'
    # print(cb + b"456")      # Output: b'123456' (inherits bytes functionality)
    # print(cb.startswith(b"12"))  # Output: True (inherits bytes functionality)
    # print(repr(cb))         # Output: CircularBytes(b'123')
