
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pydna.assembly2 &#8212; pydna 6.0.0a24.post17+b7b559bd66 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=b530ca2f" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eea9577"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pydna/assembly2';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">pydna 6.0.0a24.post17+b7b559bd66 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pydna-group/pydna" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../index.html">
                    Pydna
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../getting_started.html">Getting started</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/Dseq.html">Representing sequences in pydna</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/Dseq_Features.html">Working with Features using the Dseqrecord class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/Importing_Seqs.html">Importing and viewing sequence files in pydna</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/Restrict_Ligate_Cloning.html">Restriction and Ligation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/PCR.html">PCR</a></li>

<li class="toctree-l2"><a class="reference internal" href="../../notebooks/primer_design.html">Primer design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/Gibson.html">Gibson Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/CRISPR.html">CRISPR-Cas9</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/history.html">Cloning history / Cloning strategy</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../example_gallery.html">Example gallery</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/Example_Restriction.html">Plasmid Restriction/Ligation Cloning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/Example_Gibson.html">Gibson Assembly from the original publication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/Example_CRISPR.html">Designing a CRISPR-Cas9 toolbox for genome engineering.</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../how_pydna_works.html">How pydna works</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/new_assemblies.html">How assemblies work</a></li>


</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">API reference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../reference/pydna.html">pydna package</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/pydna-group/pydna" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for pydna.assembly2</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Improved implementation of the assembly module. To see a list of issues with the previous implementation,</span>
<span class="sd">see [issues tagged with fixed-with-new-assembly-model](https://github.com/pydna-group/pydna/issues?q=is%3Aissue%20state%3Aopen%20label%3Afixed-with-new-assembly-model)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_itertools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Bio.SeqFeature</span><span class="w"> </span><span class="kn">import</span> <span class="n">SimpleLocation</span><span class="p">,</span> <span class="n">Location</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">Bio.Restriction.Restriction</span><span class="w"> </span><span class="kn">import</span> <span class="n">RestrictionBatch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">regex</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">shift_location</span> <span class="k">as</span> <span class="n">_shift_location</span><span class="p">,</span>
    <span class="n">flatten</span><span class="p">,</span>
    <span class="n">location_boundaries</span> <span class="k">as</span> <span class="n">_location_boundaries</span><span class="p">,</span>
    <span class="n">locations_overlap</span> <span class="k">as</span> <span class="n">_locations_overlap</span><span class="p">,</span>
    <span class="n">sum_is_sticky</span><span class="p">,</span>
    <span class="n">limit_iterator</span><span class="p">,</span>
    <span class="n">create_location</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna._pretty</span><span class="w"> </span><span class="kn">import</span> <span class="n">pretty_str</span> <span class="k">as</span> <span class="n">_pretty_str</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.common_sub_strings</span><span class="w"> </span><span class="kn">import</span> <span class="n">common_sub_strings</span> <span class="k">as</span> <span class="n">common_sub_strings_str</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.dseqrecord</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dseqrecord</span> <span class="k">as</span> <span class="n">_Dseqrecord</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.dseq</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dseq</span> <span class="k">as</span> <span class="n">_Dseq</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.primer</span><span class="w"> </span><span class="kn">import</span> <span class="n">Primer</span> <span class="k">as</span> <span class="n">_Primer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.seqrecord</span><span class="w"> </span><span class="kn">import</span> <span class="n">SeqRecord</span> <span class="k">as</span> <span class="n">_SeqRecord</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.types</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">CutSiteType</span><span class="p">,</span>
    <span class="c1"># TODO: allow user to enforce multi-site</span>
    <span class="n">EdgeRepresentationAssembly</span><span class="p">,</span>
    <span class="n">SubFragmentRepresentationAssembly</span><span class="p">,</span>
    <span class="n">AssemblyAlgorithmType</span><span class="p">,</span>
    <span class="n">SequenceOverlap</span><span class="p">,</span>
    <span class="n">AssemblyEdgeType</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.gateway</span><span class="w"> </span><span class="kn">import</span> <span class="n">gateway_overlap</span><span class="p">,</span> <span class="n">find_gateway_sites</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.cre_lox</span><span class="w"> </span><span class="kn">import</span> <span class="n">cre_loxP_overlap</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.alphabet</span><span class="w"> </span><span class="kn">import</span> <span class="n">anneal_strands</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Literal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.opencloning_models</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">AssemblySource</span><span class="p">,</span>
    <span class="n">RestrictionAndLigationSource</span><span class="p">,</span>
    <span class="n">GibsonAssemblySource</span><span class="p">,</span>
    <span class="n">InFusionSource</span><span class="p">,</span>
    <span class="n">OverlapExtensionPCRLigationSource</span><span class="p">,</span>
    <span class="n">InVivoAssemblySource</span><span class="p">,</span>
    <span class="n">LigationSource</span><span class="p">,</span>
    <span class="n">GatewaySource</span><span class="p">,</span>
    <span class="n">HomologousRecombinationSource</span><span class="p">,</span>
    <span class="n">CreLoxRecombinationSource</span><span class="p">,</span>
    <span class="n">PCRSource</span><span class="p">,</span>
    <span class="n">SourceInput</span><span class="p">,</span>
    <span class="n">CRISPRSource</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.crispr</span><span class="w"> </span><span class="kn">import</span> <span class="n">cas9</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">Bio.Restriction</span><span class="w"> </span><span class="kn">import</span> <span class="n">AbstractCut</span> <span class="k">as</span> <span class="n">_AbstractCut</span>


<div class="viewcode-block" id="gather_overlapping_locations">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.gather_overlapping_locations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gather_overlapping_locations</span><span class="p">(</span>
    <span class="n">locs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Location</span><span class="p">],</span> <span class="n">fragment_length</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Location</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turn a list of locations into a list of tuples of those locations, where each tuple contains</span>
<span class="sd">    locations that overlap. For example, if locs = [loc1, loc2, loc3], and loc1 and loc2 overlap,</span>
<span class="sd">    the output will be [(loc1, loc2), (loc3,)].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make a graph with all the locations as nodes</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">locs</span><span class="p">):</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>

    <span class="c1"># Add edges between nodes that overlap</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">locs</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">_locations_overlap</span><span class="p">(</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">locs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">fragment_length</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

    <span class="c1"># Get groups of overlapping locations</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">loc_set</span> <span class="ow">in</span> <span class="n">_nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loc_set</span><span class="p">))</span>

    <span class="c1"># Sort by location of the first element in each group (does not matter which since they are overlapping)</span>
    <span class="n">groups</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">groups</span></div>



<div class="viewcode-block" id="ends_from_cutsite">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.ends_from_cutsite">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ends_from_cutsite</span><span class="p">(</span>
    <span class="n">cutsite</span><span class="p">:</span> <span class="n">CutSiteType</span><span class="p">,</span> <span class="n">seq</span><span class="p">:</span> <span class="n">_Dseq</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the sticky or blunt ends created by a restriction enzyme cut.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cutsite : CutSiteType</span>
<span class="sd">        A tuple ((cut_watson, ovhg), enzyme) describing where the cut occurs</span>
<span class="sd">    seq : _Dseq</span>
<span class="sd">        The DNA sequence being cut</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If cutsite is None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[tuple[str, str], tuple[str, str]]</span>
<span class="sd">        A tuple of two tuples, each containing the type of end (&#39;5\&#39;&#39;, &#39;3\&#39;&#39;, or &#39;blunt&#39;)</span>
<span class="sd">        and the sequence of the overhang. The first tuple is for the left end, second for the right end.</span>

<span class="sd">    &gt;&gt;&gt; from Bio.Restriction import NotI</span>
<span class="sd">    &gt;&gt;&gt; x = _Dseq(&quot;ctcgGCGGCCGCcagcggccg&quot;)</span>
<span class="sd">    &gt;&gt;&gt; x.get_cutsites(NotI)</span>
<span class="sd">    [((6, -4), NotI)]</span>
<span class="sd">    &gt;&gt;&gt; ends_from_cutsite(x.get_cutsites(NotI)[0], x)</span>
<span class="sd">    ((&quot;5&#39;&quot;, &#39;ggcc&#39;), (&quot;5&#39;&quot;, &#39;ggcc&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">cutsite</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;None is not supported&quot;</span><span class="p">)</span>

    <span class="n">cut_watson</span><span class="p">,</span> <span class="n">cut_crick</span><span class="p">,</span> <span class="n">ovhg</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">get_cut_parameters</span><span class="p">(</span><span class="n">cutsite</span><span class="p">,</span> <span class="n">is_left</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># TODO check the edge in circular</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;5&#39;&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">cut_watson</span><span class="p">:</span><span class="n">cut_crick</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">())</span><span class="o">.</span><span class="n">lower</span><span class="p">()),</span>
            <span class="p">(</span><span class="s2">&quot;5&#39;&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">cut_watson</span><span class="p">:</span><span class="n">cut_crick</span><span class="p">])</span><span class="o">.</span><span class="n">lower</span><span class="p">()),</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">ovhg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;3&#39;&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">cut_crick</span><span class="p">:</span><span class="n">cut_watson</span><span class="p">])</span><span class="o">.</span><span class="n">lower</span><span class="p">()),</span>
            <span class="p">(</span><span class="s2">&quot;3&#39;&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">cut_crick</span><span class="p">:</span><span class="n">cut_watson</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">())</span><span class="o">.</span><span class="n">lower</span><span class="p">()),</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;blunt&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;blunt&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="restriction_ligation_overlap">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.restriction_ligation_overlap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">restriction_ligation_overlap</span><span class="p">(</span>
    <span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span>
    <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span>
    <span class="n">enzymes</span><span class="o">=</span><span class="n">RestrictionBatch</span><span class="p">,</span>
    <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">allow_blunt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">SequenceOverlap</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assembly algorithm to find overlaps that would result from restriction and ligation.</span>

<span class="sd">    Like in sticky and gibson, the order matters (see example below of partial overlap)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seqx : _Dseqrecord</span>
<span class="sd">        The first sequence</span>
<span class="sd">    seqy : _Dseqrecord</span>
<span class="sd">        The second sequence</span>
<span class="sd">    enzymes : RestrictionBatch</span>
<span class="sd">        The enzymes to use</span>
<span class="sd">    partial : bool</span>
<span class="sd">        Whether to allow partial overlaps</span>
<span class="sd">    allow_blunt : bool</span>
<span class="sd">        Whether to allow blunt ends</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[SequenceOverlap]</span>
<span class="sd">        A list of overlaps between the two sequences</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import restriction_ligation_overlap</span>
<span class="sd">    &gt;&gt;&gt; from Bio.Restriction import EcoRI, RgaI, DrdI, EcoRV</span>
<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(&quot;ccGAATTCaa&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(&quot;aaaaGAATTCgg&quot;)</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_overlap(x, y, [EcoRI])</span>
<span class="sd">    [(3, 5, 4)]</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_overlap(y, x, [EcoRI])</span>
<span class="sd">    [(5, 3, 4)]</span>

<span class="sd">    Partial overlap, note how it is not symmetric</span>

<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(&quot;GACTAAAGGGTC&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(&quot;AAGCGATCGCAAGCGATCGCAA&quot;)</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_overlap(x, y, [RgaI, DrdI], partial=True)</span>
<span class="sd">    [(6, 5, 1), (6, 15, 1)]</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_overlap(y, x, [RgaI, DrdI], partial=True)</span>
<span class="sd">    []</span>

<span class="sd">    Blunt overlap, returns length of the overlap 0</span>

<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(&quot;aaGATATCcc&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(&quot;ttttGATATCaa&quot;)</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_overlap(x, y, [EcoRV], allow_blunt=True)</span>
<span class="sd">    [(5, 7, 0)]</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_overlap(y, x, [EcoRV], allow_blunt=True)</span>
<span class="sd">    [(7, 5, 0)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cuts_x</span> <span class="o">=</span> <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">get_cutsites</span><span class="p">(</span><span class="o">*</span><span class="n">enzymes</span><span class="p">)</span>
    <span class="n">cuts_y</span> <span class="o">=</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">get_cutsites</span><span class="p">(</span><span class="o">*</span><span class="n">enzymes</span><span class="p">)</span>
    <span class="c1"># If blunt ends are allowed, something similar to this could be done to allow</span>
    <span class="c1"># joining with linear sequence ends, but for now it messes up with the only_adjacent_edges</span>
    <span class="c1"># case</span>
    <span class="c1"># if allow_blunt:</span>
    <span class="c1">#     if not seqx.circular:</span>
    <span class="c1">#         cuts_x.append(((len(seqx), 0), None))</span>
    <span class="c1">#     if not seqy.circular:</span>
    <span class="c1">#         cuts_y.append(((0, 0), None))</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cut_x</span><span class="p">,</span> <span class="n">cut_y</span> <span class="ow">in</span> <span class="n">_itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">cuts_x</span><span class="p">,</span> <span class="n">cuts_y</span><span class="p">):</span>
        <span class="c1"># A blunt end</span>
        <span class="k">if</span> <span class="n">allow_blunt</span> <span class="ow">and</span> <span class="n">cut_x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cut_y</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cut_x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cut_y</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">continue</span>

        <span class="c1"># Otherwise, test overhangs</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">sum_is_sticky</span><span class="p">(</span>
            <span class="n">ends_from_cutsite</span><span class="p">(</span><span class="n">cut_x</span><span class="p">,</span> <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">ends_from_cutsite</span><span class="p">(</span><span class="n">cut_y</span><span class="p">,</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">partial</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overlap</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">x_watson</span><span class="p">,</span> <span class="n">x_crick</span><span class="p">,</span> <span class="n">x_ovhg</span> <span class="o">=</span> <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">get_cut_parameters</span><span class="p">(</span><span class="n">cut_x</span><span class="p">,</span> <span class="n">is_left</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">y_watson</span><span class="p">,</span> <span class="n">y_crick</span><span class="p">,</span> <span class="n">y_ovhg</span> <span class="o">=</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">get_cut_parameters</span><span class="p">(</span><span class="n">cut_y</span><span class="p">,</span> <span class="n">is_left</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Positions where the overlap would start for full overlap</span>
        <span class="n">left_x</span> <span class="o">=</span> <span class="n">x_watson</span> <span class="k">if</span> <span class="n">x_ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">x_crick</span>
        <span class="n">left_y</span> <span class="o">=</span> <span class="n">y_watson</span> <span class="k">if</span> <span class="n">y_ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">y_crick</span>

        <span class="c1"># Correct por partial overlaps</span>
        <span class="n">left_x</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x_ovhg</span><span class="p">)</span> <span class="o">-</span> <span class="n">overlap</span>

        <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">left_x</span><span class="p">,</span> <span class="n">left_y</span><span class="p">,</span> <span class="n">overlap</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">matches</span></div>



<div class="viewcode-block" id="combine_algorithms">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.combine_algorithms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">combine_algorithms</span><span class="p">(</span><span class="o">*</span><span class="n">algorithms</span><span class="p">:</span> <span class="n">AssemblyAlgorithmType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AssemblyAlgorithmType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine assembly algorithms, if any of them returns a match, the match is returned.</span>

<span class="sd">    This can be used for example in a ligation where you want to allow both sticky and blunt end ligation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">combined</span><span class="p">(</span><span class="n">seqx</span><span class="p">,</span> <span class="n">seqy</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">algorithm</span> <span class="ow">in</span> <span class="n">algorithms</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">+=</span> <span class="n">algorithm</span><span class="p">(</span><span class="n">seqx</span><span class="p">,</span> <span class="n">seqy</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">matches</span>

    <span class="k">return</span> <span class="n">combined</span></div>



<div class="viewcode-block" id="blunt_overlap">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.blunt_overlap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">blunt_overlap</span><span class="p">(</span>
    <span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">SequenceOverlap</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assembly algorithm to find blunt overlaps. Used for blunt ligation.</span>

<span class="sd">    It basically returns [(len(seqx), 0, 0)] if the right end of seqx is blunt and the</span>
<span class="sd">    left end of seqy is blunt (compatible with blunt ligation). Otherwise, it returns an empty list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seqx : _Dseqrecord</span>
<span class="sd">        The first sequence</span>
<span class="sd">    seqy : _Dseqrecord</span>
<span class="sd">        The second sequence</span>
<span class="sd">    limit : int</span>
<span class="sd">        There for compatibility, but it is ignored</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[SequenceOverlap]</span>
<span class="sd">        A list of overlaps between the two sequences</span>

<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import blunt_overlap</span>
<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(&quot;AAAAAA&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(&quot;TTTTTT&quot;)</span>
<span class="sd">    &gt;&gt;&gt; blunt_overlap(x, y)</span>
<span class="sd">    [(6, 0, 0)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">three_prime_end</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;blunt&quot;</span>
        <span class="ow">and</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">five_prime_end</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;blunt&quot;</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[]</span></div>



<div class="viewcode-block" id="common_sub_strings">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.common_sub_strings">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">common_sub_strings</span><span class="p">(</span>
    <span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">25</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">SequenceOverlap</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assembly algorithm to find common substrings of length == limit. see the docs of</span>
<span class="sd">    the function common_sub_strings_str for more details. It is case insensitive.</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(&quot;TAAAAAAT&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(&quot;CCaAaAaACC&quot;)</span>
<span class="sd">    &gt;&gt;&gt; common_sub_strings(x, y, limit=5)</span>
<span class="sd">    [(1, 2, 6), (1, 3, 5), (2, 2, 5)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">query_seqx</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">query_seqy</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">seqx</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="n">query_seqx</span> <span class="o">=</span> <span class="n">query_seqx</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">seqy</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="n">query_seqy</span> <span class="o">=</span> <span class="n">query_seqy</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">common_sub_strings_str</span><span class="p">(</span><span class="n">query_seqx</span><span class="p">,</span> <span class="n">query_seqy</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">seqx</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">seqy</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="c1"># Remove matches that start on the second copy of the sequence</span>
    <span class="k">if</span> <span class="n">seqx</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">seqy</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">)]</span>

    <span class="c1"># Trim lengths that span more than the sequence</span>
    <span class="k">if</span> <span class="n">seqx</span><span class="o">.</span><span class="n">circular</span> <span class="ow">or</span> <span class="n">seqy</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="n">max_match_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">))</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">max_match_length</span><span class="p">))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>

    <span class="c1"># Edge case where the sequences are identical</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="p">):</span>
        <span class="n">full_match</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="p">)),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">full_match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">full_match</span><span class="p">]</span>

    <span class="c1"># Remove duplicate matches, see example below</span>
    <span class="c1"># Let&#39;s imagine the following two sequences, where either seqy or both are circular</span>
    <span class="c1"># seqx: 01234</span>
    <span class="c1"># seqy: 123450, circular</span>
    <span class="c1">#</span>
    <span class="c1"># common_sub_strings would return [(0, 5, 5), (1, 0, 4)]</span>
    <span class="c1"># Actually, (1, 0, 4) is a subset of (0, 5, 5), the part</span>
    <span class="c1"># that does not span the origin. To remove matches like this,</span>
    <span class="c1"># We find matches where the origin is spanned in one of the sequences</span>
    <span class="c1"># only, and then remove the subset of that match that does not span the origin.</span>
    <span class="n">shifted_matches</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="n">x_span_origin</span> <span class="o">=</span> <span class="n">seqx</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span>
        <span class="n">y_span_origin</span> <span class="o">=</span> <span class="n">seqy</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_span_origin</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">y_span_origin</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span>
            <span class="n">shifted_matches</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">shift</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">x_span_origin</span> <span class="ow">and</span> <span class="n">y_span_origin</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span>
            <span class="n">shifted_matches</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">shift</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">shifted_matches</span><span class="p">]</span></div>



<div class="viewcode-block" id="gibson_overlap">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.gibson_overlap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gibson_overlap</span><span class="p">(</span><span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">25</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assembly algorithm to find terminal overlaps (e.g. for Gibson assembly).</span>
<span class="sd">    The order matters, we want alignments like:</span>

<span class="sd">    ::</span>

<span class="sd">        seqx:    oooo------xxxx</span>
<span class="sd">        seqy:              xxxx------oooo</span>
<span class="sd">        Product: oooo------xxxx------oooo</span>

<span class="sd">        Not like:</span>

<span class="sd">        seqx:               oooo------xxxx</span>
<span class="sd">        seqy:     xxxx------oooo</span>
<span class="sd">        Product (unwanted): oooo</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seqx : _Dseqrecord</span>
<span class="sd">        The first sequence</span>
<span class="sd">    seqy : _Dseqrecord</span>
<span class="sd">        The second sequence</span>
<span class="sd">    limit : int</span>
<span class="sd">        Minimum length of the overlap</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[SequenceOverlap]</span>
<span class="sd">        A list of overlaps between the two sequences</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import gibson_overlap</span>
<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(&quot;ttactaAAAAAA&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(&quot;AAAAAAcgcacg&quot;)</span>
<span class="sd">    &gt;&gt;&gt; gibson_overlap(x, y, limit=5)</span>
<span class="sd">    [(6, 0, 6), (7, 0, 5)]</span>
<span class="sd">    &gt;&gt;&gt; gibson_overlap(y, x, limit=5)</span>
<span class="sd">    []</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Because Gibson enzymes remove 5&#39; overhangs, we remove them from the sequence</span>
    <span class="c1"># when looking for homology, then we shift the location of the second fragment accordingly.</span>
    <span class="c1"># This is only relevant for linear fragments, so we don&#39;t need to worry about</span>
    <span class="c1"># shifting locations for circular fragments.</span>
    <span class="n">trim_x_left</span> <span class="o">=</span> <span class="o">-</span><span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span> <span class="k">if</span> <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">trim_x_right</span> <span class="o">=</span> <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">watson_ovhg</span> <span class="k">if</span> <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">watson_ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">trim_y_left</span> <span class="o">=</span> <span class="o">-</span><span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span> <span class="k">if</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">trim_y_right</span> <span class="o">=</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">watson_ovhg</span> <span class="k">if</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">watson_ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">stringx</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">trim_x_left</span><span class="p">:</span><span class="n">trim_x_right</span><span class="p">])</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">stringy</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">trim_y_left</span><span class="p">:</span><span class="n">trim_y_right</span><span class="p">])</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="c1"># We have to convert to list because we need to modify the matches</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">common_sub_strings_str</span><span class="p">(</span><span class="n">stringx</span><span class="p">,</span> <span class="n">stringy</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">stringx</span><span class="p">))</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
        <span class="k">match</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">trim_x_left</span>
        <span class="k">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">trim_y_left</span>

    <span class="c1"># convert to tuples again</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">]</span></div>



<div class="viewcode-block" id="sticky_end_sub_strings">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.sticky_end_sub_strings">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sticky_end_sub_strings</span><span class="p">(</span><span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assembly algorithm for ligation of sticky ends.</span>

<span class="sd">    For now, if limit 0 / False (default) only full overlaps are considered.</span>
<span class="sd">    Otherwise, partial overlaps are also returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seqx : _Dseqrecord</span>
<span class="sd">        The first sequence</span>
<span class="sd">    seqy : _Dseqrecord</span>
<span class="sd">        The second sequence</span>
<span class="sd">    limit : bool</span>
<span class="sd">        Whether to allow partial overlaps</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[SequenceOverlap]</span>
<span class="sd">        A list of overlaps between the two sequences</span>


<span class="sd">    Ligation of fully overlapping sticky ends, note how the order matters</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseq import Dseq</span>
<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import sticky_end_sub_strings</span>
<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(Dseq.from_full_sequence_and_overhangs(&quot;AAAAAA&quot;, 0, 3))</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(Dseq.from_full_sequence_and_overhangs(&quot;AAAAAA&quot;, 3, 0))</span>
<span class="sd">    &gt;&gt;&gt; sticky_end_sub_strings(x, y, limit=False)</span>
<span class="sd">    [(3, 0, 3)]</span>
<span class="sd">    &gt;&gt;&gt; sticky_end_sub_strings(y, x, limit=False)</span>
<span class="sd">    []</span>

<span class="sd">    Ligation of partially overlapping sticky ends, specified with limit=True</span>

<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(Dseq.from_full_sequence_and_overhangs(&quot;AAAAAA&quot;, 0, 2))</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(Dseq.from_full_sequence_and_overhangs(&quot;AAAAAA&quot;, 3, 0))</span>
<span class="sd">    &gt;&gt;&gt; sticky_end_sub_strings(x, y, limit=False)</span>
<span class="sd">    []</span>
<span class="sd">    &gt;&gt;&gt; sticky_end_sub_strings(x, y, limit=True)</span>
<span class="sd">    [(4, 0, 2)]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">overlap</span> <span class="o">=</span> <span class="n">sum_is_sticky</span><span class="p">(</span>
        <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">three_prime_end</span><span class="p">(),</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">five_prime_end</span><span class="p">(),</span> <span class="n">limit</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[]</span></div>



<div class="viewcode-block" id="zip_match_leftwards">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.zip_match_leftwards">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">zip_match_leftwards</span><span class="p">(</span>
    <span class="n">seqx</span><span class="p">:</span> <span class="n">_SeqRecord</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_SeqRecord</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="n">SequenceOverlap</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SequenceOverlap</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Starting from the rightmost edge of the match, return a new match encompassing the max</span>
<span class="sd">    number of bases. This can be used to return a longer match if a primer aligns for longer</span>
<span class="sd">    than the limit or a shorter match if there are mismatches. This is convenient to maintain</span>
<span class="sd">    as many features as possible. It is used in PCR assembly.</span>

<span class="sd">    &gt;&gt;&gt; seq = _Dseqrecord(&#39;AAAAACGTCCCGT&#39;)</span>
<span class="sd">    &gt;&gt;&gt; primer = _Dseqrecord(&#39;ACGTCCCGT&#39;)</span>
<span class="sd">    &gt;&gt;&gt; match = (13, 9, 0) # an empty match at the end of each</span>
<span class="sd">    &gt;&gt;&gt; zip_match_leftwards(seq, primer, match)</span>
<span class="sd">    (4, 0, 9)</span>

<span class="sd">    Works in circular molecules if the match spans the origin:</span>
<span class="sd">    &gt;&gt;&gt; seq = _Dseqrecord(&#39;TCCCGTAAAAACG&#39;, circular=True)</span>
<span class="sd">    &gt;&gt;&gt; primer = _Dseqrecord(&#39;ACGTCCCGT&#39;)</span>
<span class="sd">    &gt;&gt;&gt; match = (6, 9, 0)</span>
<span class="sd">    &gt;&gt;&gt; zip_match_leftwards(seq, primer, match)</span>
<span class="sd">    (10, 0, 9)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">query_x</span> <span class="o">=</span> <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span>
    <span class="n">query_y</span> <span class="o">=</span> <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">seqy</span><span class="p">)</span>

    <span class="c1"># In circular sequences, the match may go beyond the left-most edge of the sequence if it spans</span>
    <span class="c1"># the origin:</span>
    <span class="c1"># Primer:          ACGTCCCGT</span>
    <span class="c1">#                  |||||||||</span>
    <span class="c1"># Circular seq:    ACGTCCCGT -&gt; Equivalent to Dseqrecord(&#39;CCCGTACGT&#39;, circular=True)</span>
    <span class="c1">#                      ^</span>
    <span class="c1">#                      Origin</span>
    <span class="c1"># We would start from the last T and move leftwards, but we would stop at the origin</span>
    <span class="c1"># For those cases we shift by length, then go back</span>

    <span class="n">end_on_x</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqx</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="ow">and</span> <span class="n">seqx</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="n">end_on_x</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">):</span>
        <span class="n">end_on_x</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span>

    <span class="n">end_on_y</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqy</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="ow">and</span> <span class="n">seqy</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="n">end_on_y</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">):</span>
        <span class="n">end_on_y</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">)</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">query_x</span><span class="p">[:</span><span class="n">end_on_x</span><span class="p">]),</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">query_y</span><span class="p">[:</span><span class="n">end_on_y</span><span class="p">])):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Shift back by length if needed</span>
    <span class="n">start_on_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_on_x</span> <span class="o">-</span> <span class="n">count</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span>
    <span class="n">start_on_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_on_y</span> <span class="o">-</span> <span class="n">count</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">start_on_x</span><span class="p">,</span> <span class="n">start_on_y</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span></div>



<div class="viewcode-block" id="zip_match_rightwards">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.zip_match_rightwards">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">zip_match_rightwards</span><span class="p">(</span>
    <span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="n">SequenceOverlap</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SequenceOverlap</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as zip_match_leftwards, but towards the right.&quot;&quot;&quot;</span>

    <span class="n">query_x</span> <span class="o">=</span> <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span>
    <span class="n">query_y</span> <span class="o">=</span> <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">seqy</span><span class="p">)</span>

    <span class="n">start_on_x</span><span class="p">,</span> <span class="n">start_on_y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">match</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">query_x</span><span class="p">[</span><span class="n">start_on_x</span><span class="p">:],</span> <span class="n">query_y</span><span class="p">[</span><span class="n">start_on_y</span><span class="p">:]):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">start_on_x</span><span class="p">,</span> <span class="n">start_on_y</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span></div>



<div class="viewcode-block" id="seqrecord2_uppercase_DNA_string">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.seqrecord2_uppercase_DNA_string">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">seqr</span><span class="p">:</span> <span class="n">_SeqRecord</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform a Dseqrecord to a sequence string where U is replaced by T, everything is upper case and</span>
<span class="sd">    circular sequences are repeated twice. This is used for PCR, to support primers with U&#39;s (e.g. for USER cloning).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seqr</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqr</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="ow">and</span> <span class="n">seqr</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="primer_template_overlap">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.primer_template_overlap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">primer_template_overlap</span><span class="p">(</span>
    <span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span> <span class="o">|</span> <span class="n">_Primer</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span> <span class="o">|</span> <span class="n">_Primer</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">mismatches</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">SequenceOverlap</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assembly algorithm to find overlaps between a primer and a template. It accepts mismatches.</span>
<span class="sd">    When there are mismatches, it only returns the common part between the primer and the template.</span>

<span class="sd">    If seqx is a primer and seqy is a template, it represents the binding of a forward primer.</span>
<span class="sd">    If seqx is a template and seqy is a primer, it represents the binding of a reverse primer,</span>
<span class="sd">    where the primer has been passed as its reverse complement (see examples).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seqx : _Dseqrecord | _Primer</span>
<span class="sd">        The primer</span>
<span class="sd">    seqy : _Dseqrecord | _Primer</span>
<span class="sd">        The template</span>
<span class="sd">    limit : int</span>
<span class="sd">        Minimum length of the overlap</span>
<span class="sd">    mismatches : int</span>
<span class="sd">        Maximum number of mismatches (only substitutions, no deletion or insertion)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[SequenceOverlap]</span>
<span class="sd">        A list of overlaps between the primer and the template</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from pydna.primer import Primer</span>
<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import primer_template_overlap</span>
<span class="sd">    &gt;&gt;&gt; template = Dseqrecord(&quot;AATTAGCAGCGATCGAGT&quot;, circular=True)</span>
<span class="sd">    &gt;&gt;&gt; primer = Primer(&quot;TTAGCAGC&quot;)</span>
<span class="sd">    &gt;&gt;&gt; primer_template_overlap(primer, template, limit=8, mismatches=0)</span>
<span class="sd">    [(0, 2, 8)]</span>

<span class="sd">    This actually represents the binding of the primer ``GCTGCTAA`` (reverse complement)</span>
<span class="sd">    &gt;&gt;&gt; primer_template_overlap(template, primer, limit=8, mismatches=0)</span>
<span class="sd">    [(2, 0, 8)]</span>
<span class="sd">    &gt;&gt;&gt; primer_template_overlap(primer, template.reverse_complement(), limit=8, mismatches=0)</span>
<span class="sd">    []</span>
<span class="sd">    &gt;&gt;&gt; primer_template_overlap(primer.reverse_complement(), template, limit=8, mismatches=0)</span>
<span class="sd">    []</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqx</span><span class="p">,</span> <span class="n">_Primer</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqy</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">):</span>
        <span class="n">primer</span> <span class="o">=</span> <span class="n">seqx</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">seqy</span>
        <span class="n">reverse_primer</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqx</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqy</span><span class="p">,</span> <span class="n">_Primer</span><span class="p">):</span>
        <span class="n">primer</span> <span class="o">=</span> <span class="n">seqy</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">seqx</span>
        <span class="n">reverse_primer</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;One of the sequences must be a primer and the other a Dseqrecord&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">primer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">subject</span> <span class="o">=</span> <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
    <span class="n">query</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">primer</span><span class="p">[:</span><span class="n">limit</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">reverse_primer</span>
        <span class="k">else</span> <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">primer</span><span class="p">[</span><span class="o">-</span><span class="n">limit</span><span class="p">:])</span>
    <span class="p">)</span>

    <span class="n">re_matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">regex</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span>
            <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">query</span> <span class="o">+</span> <span class="s2">&quot;){s&lt;=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mismatches</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span> <span class="n">overlapped</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">re_matches</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">regex</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span>
            <span class="s2">&quot;(?r)(&quot;</span> <span class="o">+</span> <span class="n">query</span> <span class="o">+</span> <span class="s2">&quot;){s&lt;=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mismatches</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span> <span class="n">overlapped</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">re_match</span> <span class="ow">in</span> <span class="n">re_matches</span><span class="p">:</span>

        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">re_match</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>

        <span class="c1"># For circular sequences the same match is returned twice unless it falls</span>
        <span class="c1"># on the origin, we eliminate duplicates here</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">template</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># This extends match beyond the limit if the primer aligns more than that</span>
        <span class="c1"># and reduces the match if the primer has mismatches</span>
        <span class="k">if</span> <span class="n">reverse_primer</span><span class="p">:</span>
            <span class="c1"># Match in the same format as other assembly algorithms</span>
            <span class="n">starting_match</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">zip_match_rightwards</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">primer</span><span class="p">,</span> <span class="n">starting_match</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Match in the same format as other assembly algorithms</span>
            <span class="n">starting_match</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">primer</span><span class="p">)</span> <span class="o">-</span> <span class="n">limit</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">zip_match_leftwards</span><span class="p">(</span><span class="n">primer</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">starting_match</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">out</span><span class="p">))</span></div>



<div class="viewcode-block" id="fill_left">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.fill_left">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fill_left</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="n">_Dseq</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Dseq</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fill the left overhang of a sequence with the complementary sequence.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">seq</span><span class="o">.</span><span class="n">cast_to_ds_left</span><span class="p">()</span></div>



<div class="viewcode-block" id="fill_right">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.fill_right">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fill_right</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="n">_Dseq</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Dseq</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fill the right overhang of a sequence with the complementary sequence.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">seq</span><span class="o">.</span><span class="n">cast_to_ds_right</span><span class="p">()</span>  <span class="c1"># _Dseq(new_watson, new_crick, seq.ovhg)</span></div>



<div class="viewcode-block" id="fill_dseq">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.fill_dseq">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fill_dseq</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="n">_Dseq</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Dseq</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fill the overhangs of a sequence with the complementary sequence.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fill_left</span><span class="p">(</span><span class="n">fill_right</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span></div>



<div class="viewcode-block" id="reverse_complement_assembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.reverse_complement_assembly">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reverse_complement_assembly</span><span class="p">(</span>
    <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">,</span> <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Complement an assembly, i.e. reverse the order of the fragments and the orientation of the overlaps.&quot;&quot;&quot;</span>
    <span class="n">new_assembly</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">locu</span><span class="p">,</span> <span class="n">locv</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">:</span>
        <span class="n">f_u</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">f_v</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">new_assembly</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="o">-</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span><span class="p">,</span> <span class="n">locv</span><span class="o">.</span><span class="n">_flip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_v</span><span class="p">)),</span> <span class="n">locu</span><span class="o">.</span><span class="n">_flip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_u</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">new_assembly</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="filter_linear_subassemblies">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.filter_linear_subassemblies">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_linear_subassemblies</span><span class="p">(</span>
    <span class="n">linear_assemblies</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">],</span>
    <span class="n">circular_assemblies</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">],</span>
    <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove linear assemblies which are sub-assemblies of circular assemblies&quot;&quot;&quot;</span>
    <span class="n">all_circular_assemblies</span> <span class="o">=</span> <span class="n">circular_assemblies</span> <span class="o">+</span> <span class="p">[</span>
        <span class="n">reverse_complement_assembly</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">fragments</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">circular_assemblies</span>
    <span class="p">]</span>
    <span class="n">filtered_assemblies</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">assem</span>
        <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="n">linear_assemblies</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_sublist</span><span class="p">(</span><span class="n">assem</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">all_circular_assemblies</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="c1"># I don&#39;t think the line below is necessary, but just in case</span>
    <span class="c1"># filtered_assemblies = [l for l in filtered_assemblies if not any(is_sublist(reverse_complement_assembly(l, fragments), c, True) for c in all_circular_assemblies)]</span>
    <span class="k">return</span> <span class="n">filtered_assemblies</span></div>



<div class="viewcode-block" id="remove_subassemblies">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.remove_subassemblies">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">remove_subassemblies</span><span class="p">(</span>
    <span class="n">assemblies</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Filter out subassemblies, i.e. assemblies that are contained within another assembly.</span>

<span class="sd">    For example:</span>
<span class="sd">        [(1, 2, &#39;1[8:14]:2[1:7]&#39;), (2, 3, &#39;2[10:17]:3[1:8]&#39;)]</span>
<span class="sd">        [(1, 2, &#39;1[8:14]:2[1:7]&#39;)]</span>
<span class="sd">    The second one is a subassembly of the first one.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sort by length, longest first</span>
    <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">assemblies</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">filtered_assemblies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">assembly</span> <span class="ow">in</span> <span class="n">assemblies</span><span class="p">:</span>
        <span class="c1"># Check if this assembly is a subassembly of any of the assemblies we have already found</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_sublist</span><span class="p">(</span><span class="n">assembly</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">filtered_assemblies</span><span class="p">):</span>
            <span class="n">filtered_assemblies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filtered_assemblies</span></div>



<div class="viewcode-block" id="assembly2str">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.assembly2str">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assembly2str</span><span class="p">(</span><span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an assembly to a string representation, for example:</span>
<span class="sd">    ((1, 2, [8:14], [1:7]),(2, 3, [10:17], [1:8]))</span>
<span class="sd">    becomes:</span>
<span class="sd">    (&#39;1[8:14]:2[1:7]&#39;, &#39;2[10:17]:3[1:8]&#39;)</span>

<span class="sd">    The reason for this is that by default, a feature &#39;[8:14]&#39; when present in a tuple</span>
<span class="sd">    is printed to the console as ``SimpleLocation(ExactPosition(8), ExactPosition(14), strand=1)`` (very long).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">u</span><span class="si">}{</span><span class="n">lu</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="si">}{</span><span class="n">lv</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lu</span><span class="p">,</span> <span class="n">lv</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">))</span></div>



<div class="viewcode-block" id="assembly2str_tuple">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.assembly2str_tuple">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assembly2str_tuple</span><span class="p">(</span><span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an assembly to a string representation, like</span>
<span class="sd">    ((1, 2, [8:14], [1:7]),(2, 3, [10:17], [1:8]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">lu</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">lv</span><span class="p">))</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lu</span><span class="p">,</span> <span class="n">lv</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">))</span></div>



<div class="viewcode-block" id="assembly_has_mismatches">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.assembly_has_mismatches">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assembly_has_mismatches</span><span class="p">(</span>
    <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span> <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if an assembly has mismatches. This should never happen and if so it returns an error.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">loc_u</span><span class="p">,</span> <span class="n">loc_v</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">:</span>
        <span class="n">seq_u</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="n">u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">fragments</span><span class="p">[</span><span class="o">-</span><span class="n">u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
        <span class="n">seq_v</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">fragments</span><span class="p">[</span><span class="o">-</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
        <span class="c1"># TODO: Check issue where extraction failed, and whether it would give problems here</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">loc_u</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">seq_u</span><span class="p">)</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="n">loc_v</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">seq_v</span><span class="p">)</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="assembly_is_circular">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.assembly_is_circular">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assembly_is_circular</span><span class="p">(</span>
    <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">,</span> <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Based on the topology of the locations of an assembly, determine if it is circular.</span>
<span class="sd">    This does not work for insertion assemblies, that&#39;s why assemble takes the optional argument is_insertion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">_Dseqrecord</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">circular</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="o">&gt;</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="assemble">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.assemble">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assemble</span><span class="p">(</span>
    <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
    <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">,</span>
    <span class="n">is_insertion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Dseqrecord</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a Dseqrecord from an assembly and a list of fragments.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">is_insertion</span><span class="p">:</span>
        <span class="n">is_circular</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">is_circular</span> <span class="o">=</span> <span class="n">assembly_is_circular</span><span class="p">(</span><span class="n">assembly</span><span class="p">,</span> <span class="n">fragments</span><span class="p">)</span>

    <span class="n">subfragment_representation</span> <span class="o">=</span> <span class="n">edge_representation2subfragment_representation</span><span class="p">(</span>
        <span class="n">assembly</span><span class="p">,</span> <span class="n">is_circular</span>
    <span class="p">)</span>

    <span class="c1"># Sanity check</span>
    <span class="k">for</span> <span class="n">asm_edge</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">:</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">loc_u</span><span class="p">,</span> <span class="n">loc_v</span> <span class="o">=</span> <span class="n">asm_edge</span>
        <span class="n">f_u</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="n">u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">fragments</span><span class="p">[</span><span class="o">-</span><span class="n">u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
        <span class="n">f_v</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">fragments</span><span class="p">[</span><span class="o">-</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
        <span class="n">seq_u</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">loc_u</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">f_u</span><span class="p">)</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">seq_v</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">loc_v</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">f_v</span><span class="p">)</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">rc</span><span class="p">())</span>
        <span class="c1"># Test if seq_u and seq_v anneal</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">anneal_strands</span><span class="p">(</span><span class="n">seq_u</span><span class="p">,</span> <span class="n">seq_v</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mismatch in assembly&quot;</span><span class="p">)</span>

    <span class="c1"># We transform into Dseqrecords (for primers)</span>
    <span class="n">dseqr_fragments</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">f</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="k">else</span> <span class="n">_Dseqrecord</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fragments</span>
    <span class="p">]</span>
    <span class="n">subfragments</span> <span class="o">=</span> <span class="n">get_assembly_subfragments</span><span class="p">(</span>
        <span class="n">dseqr_fragments</span><span class="p">,</span> <span class="n">subfragment_representation</span>
    <span class="p">)</span>

    <span class="c1"># Length of the overlaps between consecutive assembly fragments</span>
    <span class="n">fragment_overlaps</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">]</span>
    <span class="n">out_dseqrecord</span> <span class="o">=</span> <span class="n">subfragments</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">overlap</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">subfragments</span><span class="p">,</span> <span class="n">fragment_overlaps</span><span class="p">):</span>
        <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">cast_to_ds_right</span><span class="p">()</span>
        <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">exo1_end</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>
        <span class="n">fragment</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">fragment</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">cast_to_ds_left</span><span class="p">()</span>
        <span class="n">fragment</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">fragment</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">exo1_front</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>
        <span class="n">out_dseqrecord</span> <span class="o">+=</span> <span class="n">fragment</span>

    <span class="c1"># For circular assemblies, process the fragment and loop</span>
    <span class="k">if</span> <span class="n">is_circular</span><span class="p">:</span>
        <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">cast_to_ds_left</span><span class="p">()</span>
        <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">cast_to_ds_right</span><span class="p">()</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">fragment_overlaps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">exo1_front</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>
        <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">exo1_end</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>
        <span class="n">out_dseqrecord</span> <span class="o">=</span> <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">looped</span><span class="p">()</span>

    <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">AssemblySource</span><span class="o">.</span><span class="n">from_subfragment_representation</span><span class="p">(</span>
        <span class="n">subfragment_representation</span><span class="p">,</span> <span class="n">fragments</span><span class="p">,</span> <span class="n">is_circular</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">out_dseqrecord</span></div>



<div class="viewcode-block" id="annotate_primer_binding_sites">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.annotate_primer_binding_sites">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">annotate_primer_binding_sites</span><span class="p">(</span>
    <span class="n">input_dseqr</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Dseqrecord</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Annotate the primer binding sites in a Dseqrecord.&quot;&quot;&quot;</span>
    <span class="n">fwd</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rvs</span> <span class="o">=</span> <span class="n">fragments</span>
    <span class="n">start_rvs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_dseqr</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rvs</span><span class="p">)</span>

    <span class="n">output_dseqr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">input_dseqr</span><span class="p">)</span>
    <span class="n">output_dseqr</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">y</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">fwd</span><span class="p">),</span>
        <span class="n">type_</span><span class="o">=</span><span class="s2">&quot;primer_bind&quot;</span><span class="p">,</span>
        <span class="n">strand</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="p">[</span><span class="n">fwd</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
        <span class="n">note</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sequence: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fwd</span><span class="o">.</span><span class="n">seq</span><span class="p">)],</span>
    <span class="p">)</span>
    <span class="n">output_dseqr</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">start_rvs</span><span class="p">,</span>
        <span class="n">y</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">output_dseqr</span><span class="p">),</span>
        <span class="n">type_</span><span class="o">=</span><span class="s2">&quot;primer_bind&quot;</span><span class="p">,</span>
        <span class="n">strand</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="p">[</span><span class="n">rvs</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
        <span class="n">note</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sequence: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rvs</span><span class="o">.</span><span class="n">seq</span><span class="p">)],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">output_dseqr</span></div>



<div class="viewcode-block" id="edge_representation2subfragment_representation">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.edge_representation2subfragment_representation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">edge_representation2subfragment_representation</span><span class="p">(</span>
    <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">,</span> <span class="n">is_circular</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SubFragmentRepresentationAssembly</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turn this kind of edge representation fragment 1, fragment 2, right edge on 1, left edge on 2</span>
<span class="sd">    a = [(1, 2, &#39;loc1a&#39;, &#39;loc2a&#39;), (2, 3, &#39;loc2b&#39;, &#39;loc3b&#39;), (3, 1, &#39;loc3c&#39;, &#39;loc1c&#39;)]</span>
<span class="sd">    Into this: fragment 1, left edge on 1, right edge on 1</span>
<span class="sd">    b = [(1, &#39;loc1c&#39;, &#39;loc1a&#39;), (2, &#39;loc2a&#39;, &#39;loc2b&#39;), (3, &#39;loc3b&#39;, &#39;loc3c&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">is_circular</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
            <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">[(</span><span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="p">)</span>
    <span class="n">edge_pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">subfragment_representation</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">_u1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">start_location</span><span class="p">),</span> <span class="p">(</span><span class="n">_u2</span><span class="p">,</span> <span class="n">_v2</span><span class="p">,</span> <span class="n">end_location</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edge_pairs</span><span class="p">:</span>
        <span class="n">subfragment_representation</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v1</span><span class="p">,</span> <span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">subfragment_representation</span><span class="p">)</span></div>



<div class="viewcode-block" id="subfragment_representation2edge_representation">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.subfragment_representation2edge_representation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">subfragment_representation2edge_representation</span><span class="p">(</span>
    <span class="n">assembly</span><span class="p">:</span> <span class="n">SubFragmentRepresentationAssembly</span><span class="p">,</span> <span class="n">is_circular</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turn this kind of subfragment representation fragment 1, left edge on 1, right edge on 1</span>
<span class="sd">    a = [(1, &#39;loc1c&#39;, &#39;loc1a&#39;), (2, &#39;loc2a&#39;, &#39;loc2b&#39;), (3, &#39;loc3b&#39;, &#39;loc3c&#39;)]</span>
<span class="sd">    Into this: fragment 1, fragment 2, right edge on 1, left edge on 2</span>
<span class="sd">    b = [(1, 2, &#39;loc1a&#39;, &#39;loc2a&#39;), (2, 3, &#39;loc2b&#39; &#39;loc3b&#39;), (3, 1, &#39;loc3c&#39;, &#39;loc1c&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">edge_representation</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate through the assembly pairwise to create the edge representation</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">frag1</span><span class="p">,</span> <span class="n">left1</span><span class="p">,</span> <span class="n">right1</span> <span class="o">=</span> <span class="n">assembly</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">frag2</span><span class="p">,</span> <span class="n">left2</span><span class="p">,</span> <span class="n">right2</span> <span class="o">=</span> <span class="n">assembly</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Create the edge between the current and next fragment</span>
        <span class="n">edge_representation</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">frag1</span><span class="p">,</span> <span class="n">frag2</span><span class="p">,</span> <span class="n">right1</span><span class="p">,</span> <span class="n">left2</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">is_circular</span><span class="p">:</span>
        <span class="c1"># Add the edge from the last fragment back to the first</span>
        <span class="n">frag_last</span><span class="p">,</span> <span class="n">left_last</span><span class="p">,</span> <span class="n">right_last</span> <span class="o">=</span> <span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">frag_first</span><span class="p">,</span> <span class="n">left_first</span><span class="p">,</span> <span class="n">right_first</span> <span class="o">=</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">edge_representation</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">frag_last</span><span class="p">,</span> <span class="n">frag_first</span><span class="p">,</span> <span class="n">right_last</span><span class="p">,</span> <span class="n">left_first</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edge_representation</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_assembly_subfragments">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.get_assembly_subfragments">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_assembly_subfragments</span><span class="p">(</span>
    <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
    <span class="n">subfragment_representation</span><span class="p">:</span> <span class="n">SubFragmentRepresentationAssembly</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From the fragment representation returned by edge_representation2subfragment_representation, get the subfragments that are joined together.</span>

<span class="sd">    Subfragments are the slices of the fragments that are joined together</span>

<span class="sd">    For example::</span>

<span class="sd">          --A--</span>
<span class="sd">        TACGTAAT</span>
<span class="sd">          --B--</span>
<span class="sd">         TCGTAACGA</span>

<span class="sd">        Gives: TACGTAA / CGTAACGA</span>

<span class="sd">    To reproduce::</span>

<span class="sd">        a = Dseqrecord(&#39;TACGTAAT&#39;)</span>
<span class="sd">        b = Dseqrecord(&#39;TCGTAACGA&#39;)</span>
<span class="sd">        f = Assembly([a, b], limit=5)</span>
<span class="sd">        a0 = f.get_linear_assemblies()[0]</span>
<span class="sd">        print(assembly2str(a0))</span>
<span class="sd">        a0_subfragment_rep =edge_representation2subfragment_representation(a0, False)</span>
<span class="sd">        for f in get_assembly_subfragments([a, b], a0_subfragment_rep):</span>
<span class="sd">            print(f.seq)</span>

<span class="sd">        # prints TACGTAA and CGTAACGA</span>

<span class="sd">    Subfragments: ``cccccgtatcgtgt``, ``atcgtgtactgtcatattc``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subfragments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span> <span class="ow">in</span> <span class="n">subfragment_representation</span><span class="p">:</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">fragments</span><span class="p">[</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">else</span> <span class="n">fragments</span><span class="p">[</span><span class="o">-</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">subfragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extract_subfragment</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">subfragments</span></div>



<div class="viewcode-block" id="extract_subfragment">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.extract_subfragment">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">extract_subfragment</span><span class="p">(</span>
    <span class="n">seq</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">start_location</span><span class="p">:</span> <span class="n">Location</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">end_location</span><span class="p">:</span> <span class="n">Location</span> <span class="o">|</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Dseqrecord</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract a subfragment from a sequence for an assembly, given the start and end locations of the subfragment.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">seq</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="p">(</span><span class="n">start_location</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">end_location</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Start and end locations cannot be None for circular sequences&quot;</span>
        <span class="p">)</span>
        <span class="c1"># This could be used to have consistent behaviour for circular sequences, where the start is arbitrary. However,</span>
        <span class="c1"># they should never get None, so this is not used.</span>
        <span class="c1"># if start_location is None:</span>
        <span class="c1">#     start_location = end_location</span>
        <span class="c1"># elif end_location is None:</span>
        <span class="c1">#     end_location = start_location</span>

    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">start_location</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">start_location</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">end_location</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">end_location</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Special case, some of it could be handled by better Dseqrecord slicing in the future</span>
    <span class="k">if</span> <span class="n">seq</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="n">_locations_overlap</span><span class="p">(</span><span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>
        <span class="c1"># The overhang is different for origin-spanning features, for instance</span>
        <span class="c1"># for a feature join{[12:13], [0:3]} in a sequence of length 13, the overhang</span>
        <span class="c1"># is -4, not 9</span>
        <span class="n">ovhg</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">end</span> <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="k">else</span> <span class="n">start</span> <span class="o">-</span> <span class="n">end</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="c1"># edge case</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ovhg</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
            <span class="n">ovhg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dummy_cut</span> <span class="o">=</span> <span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">ovhg</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">open_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">apply_cut</span><span class="p">(</span><span class="n">dummy_cut</span><span class="p">,</span> <span class="n">dummy_cut</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_Dseqrecord</span><span class="p">(</span><span class="n">fill_dseq</span><span class="p">(</span><span class="n">open_seq</span><span class="o">.</span><span class="n">seq</span><span class="p">),</span> <span class="n">features</span><span class="o">=</span><span class="n">open_seq</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">seq</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span></div>



<div class="viewcode-block" id="is_sublist">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.is_sublist">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_sublist</span><span class="p">(</span><span class="n">sublist</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">my_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">my_list_is_cyclic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns True if argument sublist is a sublist of argument my_list (can be treated as cyclic), False otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; is_sublist([1, 2], [1, 2, 3], False)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_sublist([1, 2], [1, 3, 2], False)</span>
<span class="sd">    False</span>

<span class="sd">    # See the case here for cyclic lists</span>
<span class="sd">    &gt;&gt;&gt; is_sublist([3, 1], [1, 2, 3], False)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_sublist([3, 1], [1, 2, 3], True)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">my_list_is_cyclic</span><span class="p">:</span>
        <span class="n">my_list</span> <span class="o">=</span> <span class="n">my_list</span> <span class="o">+</span> <span class="n">my_list</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_list</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Just in case tuples were passed</span>
        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">my_list</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">sublist</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="circular_permutation_min_abs">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.circular_permutation_min_abs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">circular_permutation_min_abs</span><span class="p">(</span><span class="n">lst</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the circular permutation of lst with the smallest absolute value first.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; circular_permutation_min_abs([1, 2, 3])</span>
<span class="sd">    [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; circular_permutation_min_abs([3, 1, 2])</span>
<span class="sd">    [1, 2, 3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_abs_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">lst</span><span class="p">[</span><span class="n">min_abs_index</span><span class="p">:]</span> <span class="o">+</span> <span class="n">lst</span><span class="p">[:</span><span class="n">min_abs_index</span><span class="p">]</span></div>



<div class="viewcode-block" id="Assembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Assembly</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assembly of a list of DNA fragments into linear or circular constructs.</span>
<span class="sd">    Accepts a list of Dseqrecords (source fragments) to</span>
<span class="sd">    initiate an Assembly object. Several methods are available for analysis</span>
<span class="sd">    of overlapping sequences, graph construction and assembly.</span>

<span class="sd">    The assembly contains a directed graph, where nodes represent fragments and</span>
<span class="sd">    edges represent overlaps between fragments. :</span>

<span class="sd">    - The node keys are integers, representing the index of the fragment in the</span>
<span class="sd">      input list of fragments. The sign of the node key represents the orientation</span>
<span class="sd">      of the fragment, positive for forward orientation, negative for reverse orientation.</span>
<span class="sd">    - The edges contain the locations of the overlaps in the fragments. For an edge (u, v, key):</span>
<span class="sd">        - u and v are the nodes connected by the edge.</span>
<span class="sd">        - key is a string that represents the location of the overlap. In the format:</span>
<span class="sd">          &#39;u[start:end](strand):v[start:end](strand)&#39;.</span>
<span class="sd">        - Edges have a &#39;locations&#39; attribute, which is a list of two FeatureLocation objects,</span>
<span class="sd">          representing the location of the overlap in the u and v fragment, respectively.</span>
<span class="sd">        - You can think of an edge as a representation of the join of two fragments.</span>

<span class="sd">    If fragment 1 and 2 share a subsequence of 6bp, [8:14] in fragment 1 and [1:7] in fragment 2,</span>
<span class="sd">    there will be 4 edges representing that overlap in the graph, for all possible</span>
<span class="sd">    orientations of the fragments (see add_edges_from_match for details):</span>

<span class="sd">    - ``(1, 2, &#39;1[8:14]:2[1:7]&#39;)``</span>
<span class="sd">    - ``(2, 1, &#39;2[1:7]:1[8:14]&#39;)``</span>
<span class="sd">    - ``(-1, -2, &#39;-1[0:6]:-2[10:16]&#39;)``</span>
<span class="sd">    - ``(-2, -1, &#39;-2[10:16]:-1[0:6]&#39;)``</span>

<span class="sd">    An assembly can be thought of as a tuple of graph edges, but instead of representing them with node indexes and keys, we represent them</span>
<span class="sd">    as u, v, locu, locv, where u and v are the nodes connected by the edge, and locu and locv are the locations of the overlap in the first</span>
<span class="sd">    and second fragment. Assemblies are then represented as:</span>

<span class="sd">    - Linear: ((1, 2, [8:14], [1:7]), (2, 3, [10:17], [1:8]))</span>
<span class="sd">    - Circular: ((1, 2, [8:14], [1:7]), (2, 3, [10:17], [1:8]), (3, 1, [12:17], [1:6]))</span>

<span class="sd">    Note that the first and last fragment are the same in a circular assembly.</span>

<span class="sd">    The following constrains are applied to remove duplicate assemblies:</span>

<span class="sd">    - Circular assemblies: the first subfragment is not reversed, and has the smallest index in the input fragment list.</span>
<span class="sd">      use_fragment_order is ignored.</span>
<span class="sd">    - Linear assemblies:</span>
<span class="sd">        - Using uid (see add_edges_from_match) to identify unique edges.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frags : list</span>
<span class="sd">        A list of Dseqrecord objects.</span>
<span class="sd">    limit : int, optional</span>
<span class="sd">        The shortest shared homology to be considered, this is passed as the third argument to the ``algorithm`` function.</span>
<span class="sd">        For certain algorithms, this might be ignored.</span>
<span class="sd">    algorithm : function, optional</span>
<span class="sd">        The algorithm used to determine the shared sequences. It&#39;s a function that takes two Dseqrecord objects as inputs,</span>
<span class="sd">        and will get passed the third argument (limit), that may or may not be used. It must return a list of overlaps</span>
<span class="sd">        (see common_sub_strings for an example).</span>
<span class="sd">    use_fragment_order : bool, optional</span>
<span class="sd">        It&#39;s set to True by default to reproduce legacy pydna behaviour: only assemblies that start with the first fragment and end with the last are considered.</span>
<span class="sd">        You should set it to False.</span>
<span class="sd">    use_all_fragments : bool, optional</span>
<span class="sd">        Constrain the assembly to use all fragments.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    from assembly2 import Assembly, assembly2str</span>
<span class="sd">    from pydna.dseqrecord import Dseqrecord</span>

<span class="sd">    example_fragments = (</span>
<span class="sd">        Dseqrecord(&#39;AacgatCAtgctcc&#39;, name=&#39;a&#39;),</span>
<span class="sd">        Dseqrecord(&#39;TtgctccTAAattctgc&#39;, name=&#39;b&#39;),</span>
<span class="sd">        Dseqrecord(&#39;CattctgcGAGGacgatG&#39;, name=&#39;c&#39;),</span>
<span class="sd">    )</span>

<span class="sd">    asm = Assembly(example_fragments, limit=5, use_fragment_order=False)</span>
<span class="sd">    print(&#39;Linear ===============&#39;)</span>
<span class="sd">    for assembly in asm.get_linear_assemblies():</span>
<span class="sd">        print(&#39; &#39;, assembly2str(assembly))</span>
<span class="sd">    print(&#39;Circular =============&#39;)</span>
<span class="sd">    for assembly in asm.get_circular_assemblies():</span>
<span class="sd">        print(&#39; &#39;, assembly2str(assembly))</span>

<span class="sd">    # Prints</span>
<span class="sd">    Linear ===============</span>
<span class="sd">        (&#39;1[8:14]:2[1:7]&#39;, &#39;2[10:17]:3[1:8]&#39;)</span>
<span class="sd">        (&#39;2[10:17]:3[1:8]&#39;, &#39;3[12:17]:1[1:6]&#39;)</span>
<span class="sd">        (&#39;3[12:17]:1[1:6]&#39;, &#39;1[8:14]:2[1:7]&#39;)</span>
<span class="sd">        (&#39;1[1:6]:3[12:17]&#39;,)</span>
<span class="sd">        (&#39;2[1:7]:1[8:14]&#39;,)</span>
<span class="sd">        (&#39;3[1:8]:2[10:17]&#39;,)</span>
<span class="sd">    Circular =============</span>
<span class="sd">        (&#39;1[8:14]:2[1:7]&#39;, &#39;2[10:17]:3[1:8]&#39;, &#39;3[12:17]:1[1:6]&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
        <span class="n">algorithm</span><span class="p">:</span> <span class="n">AssemblyAlgorithmType</span> <span class="o">=</span> <span class="n">common_sub_strings</span><span class="p">,</span>
        <span class="n">use_fragment_order</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">use_all_fragments</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="c1"># TODO: allow for the same fragment to be included more than once?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
        <span class="c1"># Add positive and negative nodes for forward and reverse fragments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;seq&quot;</span><span class="p">:</span> <span class="n">f</span><span class="p">})</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frags</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span>
            <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;seq&quot;</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()})</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Iterate over all possible combinations of fragments</span>
        <span class="n">fragment_pairs</span> <span class="o">=</span> <span class="n">_itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">fragment_pairs</span><span class="p">:</span>
            <span class="c1"># All the relative orientations of the fragments in the pair</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span><span class="p">]):</span>
                <span class="n">u_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s2">&quot;seq&quot;</span><span class="p">]</span>
                <span class="n">v_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s2">&quot;seq&quot;</span><span class="p">]</span>
                <span class="n">matches</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">(</span><span class="n">u_seq</span><span class="p">,</span> <span class="n">v_seq</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from_match</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u_seq</span><span class="p">,</span> <span class="n">v_seq</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">frags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="n">algorithm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_fragment_order</span> <span class="o">=</span> <span class="n">use_fragment_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span> <span class="o">=</span> <span class="n">use_all_fragments</span>

        <span class="k">return</span>

<div class="viewcode-block" id="Assembly.assembly_is_valid">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.assembly_is_valid">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">assembly_is_valid</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span> <span class="o">|</span> <span class="n">_Primer</span><span class="p">],</span>
        <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">,</span>
        <span class="n">is_circular</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">use_all_fragments</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">is_insertion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the assembly is valid, False otherwise. See function comments for conditions tested.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_circular</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Linear assemblies may get begin-1-end, begin-2-end, these are removed here.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Topology check -&gt; Circular sequences cannot be first or last in a linear assembly.</span>
        <span class="c1"># For example, let&#39;s imagine aACGTc (linear) and gACGTc (circular).</span>
        <span class="c1"># It should not be possible to join them into a linear assembly. It&#39;s similar if we</span>
        <span class="c1"># think of a restriction-ligation assembly, example: aGAATTCc (linear) and gGAATTCc</span>
        <span class="c1"># (circular).</span>
        <span class="c1"># A linear product can be generated where the circular molecule is cut open, and one end</span>
        <span class="c1"># it joins the linear molecule and on the other it&#39;s free, but for now it&#39;s not a</span>
        <span class="c1"># relevant product and it&#39;s excluded.</span>
        <span class="n">first_fragment</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">last_fragment</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_circular</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">first_fragment</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">first_fragment</span><span class="o">.</span><span class="n">circular</span>
            <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">last_fragment</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="ow">and</span> <span class="n">last_fragment</span><span class="o">.</span><span class="n">circular</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">use_all_fragments</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragments</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Here we check whether subsequent pairs of fragments are compatible, for instance:</span>
        <span class="c1"># Compatible (overlap of 1 and 2 occurs before overlap of 2 and 3):</span>
        <span class="c1"># (1,2,[2:9],[0:7]), (2,3,[12:19],[0:7])</span>
        <span class="c1">#    -- A --</span>
        <span class="c1"># 1 gtatcgtgt     -- B --</span>
        <span class="c1"># 2   atcgtgtactgtcatattc</span>
        <span class="c1"># 3               catattcaa</span>
        <span class="c1"># Incompatible (overlap of 1 and 2 occurs after overlap of 2 and 3):</span>
        <span class="c1"># (1,2,[2:9],[13:20]), (2,3,[0:7],[0:7])</span>
        <span class="c1">#                 -- A --</span>
        <span class="c1">#  1 -- B --    gtatcgtgt</span>
        <span class="c1">#  2 catattcccccccatcgtgtactgt</span>
        <span class="c1">#  3 catattcaa</span>
        <span class="c1"># Redundant: overlap of 1 and 2 ends at the same spot as overlap of 2 and 3</span>
        <span class="c1"># (1,2,[2:9],[1:8]), (2,3,[0:8],[0:8])</span>
        <span class="c1">#    -- A --</span>
        <span class="c1">#  gtatcgtgt</span>
        <span class="c1">#   catcgtgtactgtcatattc</span>
        <span class="c1">#   catcgtgtactgtcatattc</span>
        <span class="c1">#   -- B ---</span>
        <span class="k">if</span> <span class="n">is_circular</span><span class="p">:</span>
            <span class="c1"># In a circular assembly, first and last fragment must be the same</span>
            <span class="k">if</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">edge_pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">assembly</span><span class="p">,</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">assembly</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">assembly</span><span class="p">,</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">_u1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">start_location</span><span class="p">),</span> <span class="p">(</span><span class="n">_u2</span><span class="p">,</span> <span class="n">_v2</span><span class="p">,</span> <span class="n">end_location</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edge_pairs</span><span class="p">:</span>
            <span class="c1"># Incompatible as described in figure above</span>
            <span class="n">fragment</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">_Primer</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">fragment</span><span class="o">.</span><span class="n">circular</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">start_location</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">_location_boundaries</span><span class="p">(</span>
                <span class="n">end_location</span>
            <span class="p">)[</span>
                <span class="mi">1</span>
            <span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Fragments are used only once</span>
        <span class="n">nodes_used</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">edge_representation2subfragment_representation</span><span class="p">(</span>
                <span class="n">assembly</span><span class="p">,</span> <span class="n">is_circular</span> <span class="ow">or</span> <span class="n">is_insertion</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_used</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">nodes_used</span><span class="p">))):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Assembly.add_edges_from_match">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.add_edges_from_match">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_edges_from_match</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">SequenceOverlap</span><span class="p">,</span>
        <span class="n">u</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">v</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">first</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span>
        <span class="n">secnd</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add edges to the graph from a match returned by the ``algorithm`` function (see pydna.common_substrings). For</span>
<span class="sd">        format of edges (see documentation of the Assembly class).</span>

<span class="sd">        Matches are directional, because not all ``algorithm`` functions return the same match for (u,v) and (v,u). For example,</span>
<span class="sd">        homologous recombination does but sticky end ligation does not. The function returns two edges:</span>

<span class="sd">        - Fragments in the orientation they were passed, with locations of the match (u, v, loc_u, loc_v)</span>
<span class="sd">        - Reverse complement of the fragments with inverted order, with flipped locations (-v, -u, flip(loc_v), flip(loc_u))/</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_start</span><span class="p">,</span> <span class="n">y_start</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">match</span>
        <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Edge case, blunt ligation</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="p">[</span><span class="n">SimpleLocation</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="n">x_start</span><span class="p">),</span> <span class="n">SimpleLocation</span><span class="p">(</span><span class="n">y_start</span><span class="p">,</span> <span class="n">y_start</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We use shift_location with 0 to wrap origin-spanning features</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">_shift_location</span><span class="p">(</span>
                    <span class="n">SimpleLocation</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="n">x_start</span> <span class="o">+</span> <span class="n">length</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">_shift_location</span><span class="p">(</span>
                    <span class="n">SimpleLocation</span><span class="p">(</span><span class="n">y_start</span><span class="p">,</span> <span class="n">y_start</span> <span class="o">+</span> <span class="n">length</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">secnd</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">]</span>

        <span class="c1"># Flip the locations to get the reverse complement</span>
        <span class="n">rc_locs</span> <span class="o">=</span> <span class="p">[</span><span class="n">locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_flip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">first</span><span class="p">)),</span> <span class="n">locs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_flip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">secnd</span><span class="p">))]</span>

        <span class="c1"># Unique id that identifies the edge in either orientation</span>
        <span class="n">uid</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">u</span><span class="si">}{</span><span class="n">locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="si">}{</span><span class="n">locs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">combinations</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">locs</span><span class="p">),</span>
            <span class="p">(</span><span class="o">-</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span><span class="p">,</span> <span class="n">rc_locs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">u</span><span class="si">}{</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="si">}{</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">locations</span><span class="o">=</span><span class="n">l</span><span class="p">,</span> <span class="n">uid</span><span class="o">=</span><span class="n">uid</span><span class="p">)</span></div>


<div class="viewcode-block" id="Assembly.format_assembly_edge">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.format_assembly_edge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_assembly_edge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">graph_edge</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AssemblyEdgeType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Go from the (u, v, key) to the (u, v, locu, locv) format.&quot;&quot;&quot;</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">graph_edge</span>
        <span class="n">locu</span><span class="p">,</span> <span class="n">locv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">key</span><span class="p">)[</span><span class="s2">&quot;locations&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">locu</span><span class="p">,</span> <span class="n">locv</span></div>


<div class="viewcode-block" id="Assembly.get_linear_assemblies">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.get_linear_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_assemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get linear assemblies, applying the constrains described in __init__, ensuring that paths represent</span>
<span class="sd">        real assemblies (see assembly_is_valid). Subassemblies are removed (see remove_subassemblies).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Copy the graph since we will add the begin and end mock nodes</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="s2">&quot;begin&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_fragment_order</span><span class="p">:</span>
            <span class="c1"># Path must start with the first fragment and end with the last</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;begin&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;begin&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">),</span> <span class="s2">&quot;end&quot;</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">),</span> <span class="s2">&quot;end&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;begin&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">)</span>

        <span class="n">unique_linear_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_linear_paths</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">possible_assemblies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_possible_assembly_number</span><span class="p">(</span><span class="n">unique_linear_paths</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">possible_assemblies</span> <span class="o">&gt;</span> <span class="n">max_assemblies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Too many assemblies (</span><span class="si">{</span><span class="n">possible_assemblies</span><span class="si">}</span><span class="s2"> pre-validation) to assemble&quot;</span>
            <span class="p">)</span>

        <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_path2assembly_list</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">unique_linear_paths</span><span class="p">),</span>
            <span class="p">[],</span>
        <span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">only_adjacent_edges</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">out</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_uses_only_adjacent_edges</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">remove_subassemblies</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="Assembly.node_path2assembly_list">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.node_path2assembly_list">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">node_path2assembly_list</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cycle</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">circular</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a node path in the format [1, 2, 3] (as returned by _nx.cycles.simple_cycles) to a list of all</span>
<span class="sd">          possible assemblies.</span>

<span class="sd">        There may be multiple assemblies for a given node path, if there are several edges connecting two nodes,</span>
<span class="sd">        for example two overlaps between 1 and 2, and single overlap between 2 and 3 should return 3 assemblies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">combine</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">pairing</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">cycle</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">cycle</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">circular</span> <span class="k">else</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">cycle</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pairing</span><span class="p">:</span>
            <span class="n">combine</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]])</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format_assembly_edge</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">combine</span><span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Assembly.get_unique_linear_paths">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.get_unique_linear_paths">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_unique_linear_paths</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">G_with_begin_end</span><span class="p">:</span> <span class="n">_nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">,</span> <span class="n">max_paths</span><span class="o">=</span><span class="mi">10000</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get unique linear paths from the graph, removing those that contain the same node twice.&quot;&quot;&quot;</span>
        <span class="c1"># We remove the begin and end nodes, and get all paths without edges</span>
        <span class="c1"># e.g. we will get [1, 2, 3] only once, even if multiple edges connect</span>
        <span class="c1"># 1 and 2 or 2 and 3, by converting to DiGraph.</span>

        <span class="c1"># Cutoff has a different meaning of what one would expect, see https://github.com/networkx/networkx/issues/2762</span>
        <span class="n">node_paths</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">limit_iterator</span><span class="p">(</span>
                <span class="n">_nx</span><span class="o">.</span><span class="n">all_simple_paths</span><span class="p">(</span>
                    <span class="n">_nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">G_with_begin_end</span><span class="p">),</span>
                    <span class="s2">&quot;begin&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;end&quot;</span><span class="p">,</span>
                    <span class="n">cutoff</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="n">max_paths</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Remove those that contain the same node twice</span>
        <span class="n">node_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_paths</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">x</span><span class="p">)))]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">:</span>
            <span class="n">node_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_paths</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)]</span>

        <span class="c1"># For each path, we check if there are reverse complement duplicates</span>
        <span class="c1"># See: https://github.com/manulera/OpenCloning_backend/issues/160</span>
        <span class="n">unique_node_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node_paths</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_node_paths</span><span class="p">:</span>
                <span class="n">unique_node_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unique_node_paths</span></div>


<div class="viewcode-block" id="Assembly.get_possible_assembly_number">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.get_possible_assembly_number">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_possible_assembly_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of possible assemblies from a list of node paths. Basically, for each path</span>
<span class="sd">        passed as a list of integers / nodes, we calculate the number of paths possible connecting</span>
<span class="sd">        the nodes in that order, given the graph (all the edges connecting them).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">possibilities</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="n">this_path</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                    <span class="n">this_path</span> <span class="o">*=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span>
            <span class="n">possibilities</span> <span class="o">+=</span> <span class="n">this_path</span>
        <span class="k">return</span> <span class="n">possibilities</span></div>


<div class="viewcode-block" id="Assembly.get_circular_assemblies">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.get_circular_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_circular_assemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get circular assemblies, applying the constrains described in __init__, ensuring that paths represent</span>
<span class="sd">        real assemblies (see assembly_is_valid).&quot;&quot;&quot;</span>
        <span class="c1"># The constrain of circular sequence is that the first node is the fragment with the smallest index in its initial orientation,</span>
        <span class="c1"># this is ensured by the circular_permutation_min_abs function + the filter below</span>
        <span class="n">sorted_cycles</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span>
            <span class="n">circular_permutation_min_abs</span><span class="p">,</span>
            <span class="n">limit_iterator</span><span class="p">(</span>
                <span class="n">_nx</span><span class="o">.</span><span class="n">cycles</span><span class="o">.</span><span class="n">simple_cycles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">length_bound</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)),</span>
                <span class="mi">10000</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="n">sorted_cycles</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sorted_cycles</span><span class="p">)</span>
        <span class="c1"># cycles.simple_cycles returns lists [1,2,3] not assemblies, see self.cycle2circular_assemblies</span>

        <span class="c1"># We apply constrains already here because sometimes the combinatorial explosion is too large</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">:</span>
            <span class="n">sorted_cycles</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sorted_cycles</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)]</span>

        <span class="c1"># Remove cycles with duplicates</span>
        <span class="n">sorted_cycles</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sorted_cycles</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">c</span><span class="p">)))]</span>
        <span class="n">possible_assembly_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_possible_assembly_number</span><span class="p">(</span>
            <span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sorted_cycles</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">possible_assembly_number</span> <span class="o">&gt;</span> <span class="n">max_assemblies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Too many assemblies (</span><span class="si">{</span><span class="n">possible_assembly_number</span><span class="si">}</span><span class="s2"> pre-validation) to assemble&quot;</span>
            <span class="p">)</span>

        <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_path2assembly_list</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">sorted_cycles</span><span class="p">),</span> <span class="p">[]</span>
        <span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">only_adjacent_edges</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">out</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_uses_only_adjacent_edges</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="Assembly.format_insertion_assembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.format_insertion_assembly">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_insertion_assembly</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EdgeRepresentationAssembly</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sorts the fragment representing a cycle so that they represent an insertion assembly if possible,</span>
<span class="sd">        else returns None.</span>

<span class="sd">        Here we check if one of the joins between fragments represents the edges of an insertion assembly</span>
<span class="sd">        The fragment must be linear, and the join must be as indicated below</span>

<span class="sd">        ::</span>

<span class="sd">            --------         -------           Fragment 1</span>
<span class="sd">                ||            ||</span>
<span class="sd">                xxxxxxxx      ||               Fragment 2</span>
<span class="sd">                      ||      ||</span>
<span class="sd">                      oooooooooo               Fragment 3</span>

<span class="sd">        The above example will be [(1, 2, [4:6], [0:2]), (2, 3, [6:8], [0:2]), (3, 1, [8:10], [9:11)])]</span>

<span class="sd">        These could be returned in any order by simple_cycles, so we sort the edges so that the first</span>
<span class="sd">        and last ``u`` and ``v`` match the fragment that gets the insertion (1 in the example above).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_pair_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Pair edges with one another</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">((</span><span class="n">_u1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">end_location</span><span class="p">),</span> <span class="p">(</span><span class="n">_u2</span><span class="p">,</span> <span class="n">_v2</span><span class="p">,</span> <span class="n">start_location</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">assembly</span><span class="p">,</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">assembly</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="n">fragment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Find the pair of edges that should be last and first  ((3, 1, [8:10], [9:11)]), (1, 2, [4:6], [0:2]) in</span>
            <span class="c1"># the example above. Only one of the pairs of edges should satisfy this condition for the topology to make sense.</span>
            <span class="n">left_of_insertion</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">start_location</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">right_of_insertion</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">end_location</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fragment</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">right_of_insertion</span> <span class="o">&gt;=</span> <span class="n">left_of_insertion</span>
                <span class="c1"># The below condition is for single-site integration.</span>
                <span class="c1"># The reason to use locations_overlap instead of equality is because the location might extend</span>
                <span class="c1"># left of right. For example, let&#39;s take ACCGGTTT as homology arm for an integration:</span>
                <span class="c1">#</span>
                <span class="c1"># insert aaACCGGTTTccACCGGTTTtt</span>
                <span class="c1"># genome aaACCGGTTTtt</span>
                <span class="c1">#</span>
                <span class="c1"># The locations of homology on the genome are [0:10] and [2:12], so not identical</span>
                <span class="c1"># but they overlap.</span>
                <span class="ow">or</span> <span class="n">_locations_overlap</span><span class="p">(</span><span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="n">edge_pair_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_pair_index</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">shift_by</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge_pair_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">assembly</span><span class="p">[</span><span class="n">shift_by</span><span class="p">:]</span> <span class="o">+</span> <span class="n">assembly</span><span class="p">[:</span><span class="n">shift_by</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assembly.format_insertion_assembly_edge_case">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.format_insertion_assembly_edge_case">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_insertion_assembly_edge_case</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Edge case from https://github.com/manulera/OpenCloning_backend/issues/329</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">same_assembly</span> <span class="o">=</span> <span class="n">assembly</span><span class="p">[:]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">same_assembly</span>
        <span class="p">((</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">loc_f1_1</span><span class="p">,</span> <span class="n">loc_f2_1</span><span class="p">),</span> <span class="p">(</span><span class="n">_f2</span><span class="p">,</span> <span class="n">_f1</span><span class="p">,</span> <span class="n">loc_f2_2</span><span class="p">,</span> <span class="n">loc_f1_2</span><span class="p">))</span> <span class="o">=</span> <span class="n">assembly</span>

        <span class="k">if</span> <span class="n">f1</span> <span class="o">!=</span> <span class="n">_f1</span> <span class="ow">or</span> <span class="n">_f2</span> <span class="o">!=</span> <span class="n">f2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">same_assembly</span>

        <span class="k">if</span> <span class="n">loc_f2_1</span> <span class="o">==</span> <span class="n">loc_f2_2</span> <span class="ow">or</span> <span class="n">loc_f1_2</span> <span class="o">==</span> <span class="n">loc_f1_1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">same_assembly</span>

        <span class="n">fragment1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">fragment2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_locations_overlap</span><span class="p">(</span>
            <span class="n">loc_f1_1</span><span class="p">,</span> <span class="n">loc_f1_2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment1</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_locations_overlap</span><span class="p">(</span><span class="n">loc_f2_2</span><span class="p">,</span> <span class="n">loc_f2_1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment2</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">same_assembly</span>

        <span class="c1"># Sort to make compatible with insertion assembly</span>
        <span class="k">if</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">loc_f1_1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">loc_f1_2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">new_assembly</span> <span class="o">=</span> <span class="n">same_assembly</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_assembly</span> <span class="o">=</span> <span class="n">same_assembly</span><span class="p">[:]</span>

        <span class="p">((</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">loc_f1_1</span><span class="p">,</span> <span class="n">loc_f2_1</span><span class="p">),</span> <span class="p">(</span><span class="n">_f2</span><span class="p">,</span> <span class="n">_f1</span><span class="p">,</span> <span class="n">loc_f2_2</span><span class="p">,</span> <span class="n">loc_f1_2</span><span class="p">))</span> <span class="o">=</span> <span class="n">new_assembly</span>

        <span class="n">fragment1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fragment1</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">same_assembly</span>
        <span class="n">fragment2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Extract boundaries</span>
        <span class="n">f2_1_start</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">loc_f2_1</span><span class="p">)</span>
        <span class="n">f2_2_start</span><span class="p">,</span> <span class="n">f2_2_end</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">loc_f2_2</span><span class="p">)</span>
        <span class="n">f1_1_start</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">loc_f1_1</span><span class="p">)</span>
        <span class="n">f1_2_start</span><span class="p">,</span> <span class="n">f1_2_end</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">loc_f1_2</span><span class="p">)</span>

        <span class="n">overlap_diff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment1</span><span class="p">[</span><span class="n">f1_1_start</span><span class="p">:</span><span class="n">f1_2_end</span><span class="p">])</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">fragment2</span><span class="p">[</span><span class="n">f2_1_start</span><span class="p">:</span><span class="n">f2_2_end</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">overlap_diff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Overlap is 0&quot;</span>

        <span class="k">if</span> <span class="n">overlap_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_loc_f1_1</span> <span class="o">=</span> <span class="n">create_location</span><span class="p">(</span>
                <span class="n">f1_1_start</span><span class="p">,</span> <span class="n">f1_2_start</span> <span class="o">-</span> <span class="n">overlap_diff</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">new_loc_f2_1</span> <span class="o">=</span> <span class="n">create_location</span><span class="p">(</span><span class="n">f2_1_start</span><span class="p">,</span> <span class="n">f2_2_start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_loc_f2_1</span> <span class="o">=</span> <span class="n">create_location</span><span class="p">(</span>
                <span class="n">f2_1_start</span><span class="p">,</span> <span class="n">f2_2_start</span> <span class="o">+</span> <span class="n">overlap_diff</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment2</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">new_loc_f1_1</span> <span class="o">=</span> <span class="n">create_location</span><span class="p">(</span><span class="n">f1_1_start</span><span class="p">,</span> <span class="n">f1_2_start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment1</span><span class="p">))</span>

        <span class="n">new_assembly</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">new_loc_f1_1</span><span class="p">,</span> <span class="n">new_loc_f2_1</span><span class="p">),</span>
            <span class="n">new_assembly</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">new_assembly</span></div>


<div class="viewcode-block" id="Assembly.get_insertion_assemblies">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.get_insertion_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_insertion_assemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemblies that represent the insertion of a fragment or series of fragment inside a linear construct. For instance,</span>
<span class="sd">        digesting CCCCGAATTCCCCGAATTC with EcoRI and inserting the fragment with two overhangs into the EcoRI site of AAAGAATTCAAA.</span>
<span class="sd">        This is not so much meant for the use-case of linear fragments that represent actual linear fragments, but for linear</span>
<span class="sd">        fragments that represent a genome region. This can then be used to simulate homologous recombination.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">only_adjacent_edges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;only_adjacent_edges not implemented for insertion assemblies&quot;</span>
            <span class="p">)</span>

        <span class="n">cycles</span> <span class="o">=</span> <span class="n">limit_iterator</span><span class="p">(</span><span class="n">_nx</span><span class="o">.</span><span class="n">cycles</span><span class="o">.</span><span class="n">simple_cycles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">),</span> <span class="mi">10000</span><span class="p">)</span>

        <span class="c1"># We apply constrains already here because sometimes the combinatorial explosion is too large</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">:</span>
            <span class="n">cycles</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cycles</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)]</span>

        <span class="c1"># Remove cycles with duplicates</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cycles</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">c</span><span class="p">)))]</span>

        <span class="n">possible_assembly_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_possible_assembly_number</span><span class="p">(</span>
            <span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cycles</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">possible_assembly_number</span> <span class="o">&gt;</span> <span class="n">max_assemblies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Too many assemblies (</span><span class="si">{</span><span class="n">possible_assembly_number</span><span class="si">}</span><span class="s2"> pre-validation) to assemble&quot;</span>
            <span class="p">)</span>

        <span class="c1"># We find cycles first</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="n">limit_iterator</span><span class="p">(</span><span class="n">_nx</span><span class="o">.</span><span class="n">cycles</span><span class="o">.</span><span class="n">simple_cycles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">),</span> <span class="mi">10000</span><span class="p">)</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_path2assembly_list</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">iterator</span><span class="p">),</span> <span class="p">[]</span>
        <span class="p">)</span>
        <span class="c1"># We format the edge case</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">format_insertion_assembly_edge_case</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span><span class="p">]</span>
        <span class="c1"># We select those that contain exactly only one suitable edge</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">b</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_insertion_assembly</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="c1"># First fragment should be in the + orientation</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">assemblies</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_is_valid</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">,</span> <span class="n">is_insertion</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Assembly.assemble_linear">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.assemble_linear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_linear</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble linear constructs, from assemblies returned by self.get_linear_assemblies.&quot;&quot;&quot;</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linear_assemblies</span><span class="p">(</span><span class="n">only_adjacent_edges</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assembly.assemble_circular">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.assemble_circular">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_circular</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble circular constructs, from assemblies returned by self.get_circular_assemblies.&quot;&quot;&quot;</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circular_assemblies</span><span class="p">(</span><span class="n">only_adjacent_edges</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assembly.assemble_insertion">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.assemble_insertion">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_insertion</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble insertion constructs, from assemblies returned by self.get_insertion_assemblies.&quot;&quot;&quot;</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_insertion_assemblies</span><span class="p">(</span><span class="n">only_adjacent_edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">is_insertion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assembly.get_locations_on_fragments">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.get_locations_on_fragments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_locations_on_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Location</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a dictionary where the keys are the nodes in the graph, and the values are dictionaries with keys</span>
<span class="sd">        ``left``, ``right``, containing (for each fragment) the locations where the fragment is joined to another fragment on its left</span>
<span class="sd">        and right side. The values in ``left`` and ``right`` are often the same, except in restriction-ligation with partial overlap enabled,</span>
<span class="sd">        where we can end up with a situation like this:</span>

<span class="sd">        GGTCTCCCCAATT and aGGTCTCCAACCAA as fragments</span>

<span class="sd">        # Partial overlap in assembly 1[9:11]:2[8:10]</span>
<span class="sd">        GGTCTCCxxAACCAA</span>
<span class="sd">        CCAGAGGGGTTxxTT</span>

<span class="sd">        # Partial overlap in 2[10:12]:1[7:9]</span>
<span class="sd">        aGGTCTCCxxCCAATT</span>
<span class="sd">        tCCAGAGGTTGGxxAA</span>

<span class="sd">        Would return::</span>

<span class="sd">            {</span>
<span class="sd">                1: {&#39;left&#39;: [7:9], &#39;right&#39;: [9:11]},</span>
<span class="sd">                2: {&#39;left&#39;: [8:10], &#39;right&#39;: [10:12]},</span>
<span class="sd">                -1: {&#39;left&#39;: [2:4], &#39;right&#39;: [4:6]},</span>
<span class="sd">                -2: {&#39;left&#39;: [2:4], &#39;right&#39;: [4:6]}</span>
<span class="sd">            }</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">locations_on_fragments</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">this_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(),</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">()}</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                        <span class="n">edge_location</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;locations&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">edge_location</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">this_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                            <span class="n">this_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_location</span><span class="p">)</span>
            <span class="n">this_dict</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">this_dict</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">this_dict</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">this_dict</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_dict</span>

        <span class="k">return</span> <span class="n">locations_on_fragments</span></div>


<div class="viewcode-block" id="Assembly.assembly_uses_only_adjacent_edges">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.Assembly.assembly_uses_only_adjacent_edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assembly_uses_only_adjacent_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assembly</span><span class="p">,</span> <span class="n">is_circular</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether only adjacent edges within each fragment are used in the assembly. This is useful to check if a cut and ligate assembly is valid,</span>
<span class="sd">        and prevent including partially digested fragments. For example, imagine the following fragment being an input for a digestion</span>
<span class="sd">        and ligation assembly, where the enzyme cuts at the sites indicated by the vertical lines:</span>

<span class="sd">        ::</span>

<span class="sd">                     x       y       z</span>
<span class="sd">              -------|-------|-------|---------</span>

<span class="sd">        We would only want assemblies that contain subfragments start-x, x-y, y-z, z-end, and not start-x, y-end, for instance.</span>
<span class="sd">        The latter would indicate that the fragment was partially digested.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">locations_on_fragments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locations_on_fragments</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">locations_on_fragments</span><span class="p">:</span>
            <span class="n">fragment_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">]:</span>
                <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">side</span><span class="p">]</span> <span class="o">=</span> <span class="n">gather_overlapping_locations</span><span class="p">(</span>
                    <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">side</span><span class="p">],</span> <span class="n">fragment_len</span>
                <span class="p">)</span>

        <span class="n">allowed_location_pairs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">locations_on_fragments</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_circular</span><span class="p">:</span>
                <span class="c1"># We add the existing ends of the fragment</span>
                <span class="n">left</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,)]</span> <span class="o">+</span> <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">]</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,)]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># For circular assemblies, we add the first location at the end</span>
                <span class="c1"># to allow for the last edge to be used</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">]</span>
                <span class="n">right</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="o">+</span> <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">][:</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
                <span class="n">pairs</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">pair</span><span class="p">))</span>
            <span class="n">allowed_location_pairs</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">pairs</span>

        <span class="n">fragment_assembly</span> <span class="o">=</span> <span class="n">edge_representation2subfragment_representation</span><span class="p">(</span>
            <span class="n">assembly</span><span class="p">,</span> <span class="n">is_circular</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span> <span class="ow">in</span> <span class="n">fragment_assembly</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_location_pairs</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># https://pyformat.info</span>
        <span class="k">return</span> <span class="n">_pretty_str</span><span class="p">(</span>
            <span class="s2">&quot;Assembly</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;fragments..: </span><span class="si">{sequences}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;limit(bp)..: </span><span class="si">{limit}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;G.nodes....: </span><span class="si">{nodes}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;algorithm..: </span><span class="si">{al}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">sequences</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">bp&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">),</span>
                <span class="n">limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">,</span>
                <span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span>
                <span class="n">al</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="PCRAssembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.PCRAssembly">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PCRAssembly</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An assembly that represents a PCR, where ``fragments`` is a list of primer, template, primer (in that order).</span>
<span class="sd">    It always uses the ``primer_template_overlap`` algorithm and accepts the ``mismatches`` argument to indicate</span>
<span class="sd">    the number of mismatches allowed in the overlap. Only supports substitution mismatches, not indels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span> <span class="o">|</span> <span class="n">_Primer</span><span class="p">],</span> <span class="n">limit</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">mismatches</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="n">value_error</span> <span class="o">=</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;PCRAssembly assembly must be initialised with a list/tuple of primer, template, primer&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">value_error</span>

        <span class="c1"># Validate the inputs: should be a series of primer, template, primer</span>
        <span class="n">wrong_fragment_class</span> <span class="o">=</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_Primer</span><span class="p">),</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_Primer</span><span class="p">),</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">_Primer</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">wrong_fragment_class</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">value_error</span>

        <span class="c1"># TODO: allow for the same fragment to be included more than once?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
        <span class="c1"># Add positive and negative nodes for forward and reverse fragments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;seq&quot;</span><span class="p">:</span> <span class="n">f</span><span class="p">})</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frags</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span>
            <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;seq&quot;</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()})</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">primer_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">),</span> <span class="mi">3</span><span class="p">):</span>
            <span class="c1"># primer, template, primer</span>
            <span class="n">p1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">primer_ids</span> <span class="o">+=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>
            <span class="n">pairs</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">],</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="p">]))</span>
            <span class="n">pairs</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">p1</span><span class="p">,</span> <span class="o">-</span><span class="n">p2</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="n">u_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s2">&quot;seq&quot;</span><span class="p">]</span>
            <span class="n">v_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s2">&quot;seq&quot;</span><span class="p">]</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">primer_template_overlap</span><span class="p">(</span><span class="n">u_seq</span><span class="p">,</span> <span class="n">v_seq</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">mismatches</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from_match</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u_seq</span><span class="p">,</span> <span class="n">v_seq</span><span class="p">)</span>

        <span class="c1"># These two are constrained</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_fragment_order</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">frags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="n">primer_template_overlap</span>

        <span class="k">return</span>

<div class="viewcode-block" id="PCRAssembly.get_linear_assemblies">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.PCRAssembly.get_linear_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_assemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">only_adjacent_edges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;only_adjacent_edges not implemented for PCR assemblies&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_linear_assemblies</span><span class="p">(</span><span class="n">max_assemblies</span><span class="o">=</span><span class="n">max_assemblies</span><span class="p">)</span></div>


<div class="viewcode-block" id="PCRAssembly.get_circular_assemblies">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.PCRAssembly.get_circular_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_circular_assemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;get_circular_assemblies not implemented for PCR assemblies&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PCRAssembly.get_insertion_assemblies">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.PCRAssembly.get_insertion_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_insertion_assemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;get_insertion_assemblies not implemented for PCR assemblies&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PCRAssembly.assemble_linear">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.PCRAssembly.assemble_linear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_linear</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides the parent method to ensure that the 5&#39; of the crick strand of the product matches the</span>
<span class="sd">        sequence of the reverse primer. This is important when using primers with dUTP (for USER cloning).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">assemble_linear</span><span class="p">(</span><span class="n">only_adjacent_edges</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="n">rp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">seq</span><span class="p">[:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">rp</span><span class="p">)]</span> <span class="o">+</span> <span class="n">_Dseq</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rp</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">rc</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">results</span></div>
</div>



<div class="viewcode-block" id="SingleFragmentAssembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.SingleFragmentAssembly">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SingleFragmentAssembly</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An assembly that represents the circularisation or splicing of a single fragment.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frags</span><span class="p">:</span> <span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span> <span class="n">limit</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">common_sub_strings</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;SingleFragmentAssembly assembly must be initialised with a single fragment&quot;</span>
            <span class="p">)</span>
        <span class="c1"># TODO: allow for the same fragment to be included more than once?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
        <span class="n">frag</span> <span class="o">=</span> <span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Add positive and negative nodes for forward and reverse fragments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">seq</span><span class="o">=</span><span class="n">frag</span><span class="p">)</span>

        <span class="n">matches</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from_match</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="n">frag</span><span class="p">)</span>

        <span class="c1"># To avoid duplicated outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])</span>

        <span class="c1"># These two are constrained</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_fragment_order</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">frags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="n">algorithm</span>

        <span class="k">return</span>

<div class="viewcode-block" id="SingleFragmentAssembly.get_circular_assemblies">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.SingleFragmentAssembly.get_circular_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_circular_assemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
        <span class="c1"># We don&#39;t want the same location twice</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_circular_assemblies</span><span class="p">(</span><span class="n">only_adjacent_edges</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="SingleFragmentAssembly.get_insertion_assemblies">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.SingleFragmentAssembly.get_insertion_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_insertion_assemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This could be renamed splicing assembly, but the essence is similar&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">only_adjacent_edges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;only_adjacent_edges not implemented for insertion assemblies&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">splicing_assembly_filter</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c1"># We don&#39;t want the same location twice</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># We don&#39;t want to get overlap only (e.g. GAATTCcatGAATTC giving GAATTC)</span>
            <span class="n">left_start</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">right_end</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">left_start</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">right_end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># We don&#39;t want the same location twice</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="n">splicing_assembly_filter</span><span class="p">,</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_insertion_assemblies</span><span class="p">(</span><span class="n">max_assemblies</span><span class="o">=</span><span class="n">max_assemblies</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_is_valid</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">,</span> <span class="n">is_insertion</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="SingleFragmentAssembly.get_linear_assemblies">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.SingleFragmentAssembly.get_linear_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_assemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Linear assembly does not make sense&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="common_function_assembly_products">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.common_function_assembly_products">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">common_function_assembly_products</span><span class="p">(</span>
    <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
    <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">algorithm</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">circular_only</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">filter_results_function</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Common function to avoid code duplication. Could be simplified further</span>
<span class="sd">    once SingleFragmentAssembly and Assembly are merged.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frags : list[_Dseqrecord]</span>
<span class="sd">        List of DNA fragments to assemble</span>
<span class="sd">    limit : int or None</span>
<span class="sd">        Minimum overlap length required, or None if not applicable</span>
<span class="sd">    algorithm : Callable</span>
<span class="sd">        Function that determines valid overlaps between fragments</span>
<span class="sd">    circular_only : bool</span>
<span class="sd">        If True, only return circular assemblies</span>
<span class="sd">    filter_results_function : Callable or None</span>
<span class="sd">        Function that filters the results</span>
<span class="sd">    only_adjacent_edges : bool</span>
<span class="sd">        If True, only return assemblies that use only adjacent edges</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of assembled DNA molecules</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">asm</span> <span class="o">=</span> <span class="n">SingleFragmentAssembly</span><span class="p">(</span><span class="n">frags</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">asm</span> <span class="o">=</span> <span class="n">Assembly</span><span class="p">(</span>
            <span class="n">frags</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">use_fragment_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_all_fragments</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="n">output_assemblies</span> <span class="o">=</span> <span class="n">asm</span><span class="o">.</span><span class="n">get_circular_assemblies</span><span class="p">(</span><span class="n">only_adjacent_edges</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">circular_only</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">output_assemblies</span> <span class="o">+=</span> <span class="n">filter_linear_subassemblies</span><span class="p">(</span>
            <span class="n">asm</span><span class="o">.</span><span class="n">get_linear_assemblies</span><span class="p">(</span><span class="n">only_adjacent_edges</span><span class="p">),</span> <span class="n">output_assemblies</span><span class="p">,</span> <span class="n">frags</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">circular_only</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">output_assemblies</span> <span class="o">+=</span> <span class="n">asm</span><span class="o">.</span><span class="n">get_insertion_assemblies</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">filter_results_function</span><span class="p">:</span>
        <span class="n">output_assemblies</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">output_assemblies</span> <span class="k">if</span> <span class="n">filter_results_function</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">assemble</span><span class="p">(</span><span class="n">frags</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">output_assemblies</span><span class="p">]</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_recast_sources</span><span class="p">(</span>
    <span class="n">products</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span> <span class="n">source_cls</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_fields</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recast the `source` of each product to `source_cls` with optional extras.</span>

<span class="sd">    This avoids repeating the same for-loop across many assembly functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">products</span><span class="p">:</span>
        <span class="n">prod</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source_cls</span><span class="p">(</span>
            <span class="o">**</span><span class="n">prod</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">to_unserialized_dict</span><span class="p">(),</span>
            <span class="o">**</span><span class="n">extra_fields</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">products</span>


<div class="viewcode-block" id="gibson_assembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.gibson_assembly">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gibson_assembly</span><span class="p">(</span>
    <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span> <span class="n">circular_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products for Gibson assembly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frags : list[_Dseqrecord]</span>
<span class="sd">        List of DNA fragments to assemble</span>
<span class="sd">    limit : int, optional</span>
<span class="sd">        Minimum overlap length required, by default 25</span>
<span class="sd">    circular_only : bool, optional</span>
<span class="sd">        If True, only return circular assemblies, by default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of assembled DNA molecules</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">products</span> <span class="o">=</span> <span class="n">common_function_assembly_products</span><span class="p">(</span>
        <span class="n">frags</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">gibson_overlap</span><span class="p">,</span> <span class="n">circular_only</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_recast_sources</span><span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="n">GibsonAssemblySource</span><span class="p">)</span></div>



<div class="viewcode-block" id="in_fusion_assembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.in_fusion_assembly">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">in_fusion_assembly</span><span class="p">(</span>
    <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span> <span class="n">circular_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products for in-fusion assembly. This is the same as Gibson</span>
<span class="sd">    assembly, but with a different name.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frags : list[_Dseqrecord]</span>
<span class="sd">        List of DNA fragments to assemble</span>
<span class="sd">    limit : int, optional</span>
<span class="sd">        Minimum overlap length required, by default 25</span>
<span class="sd">    circular_only : bool, optional</span>
<span class="sd">        If True, only return circular assemblies, by default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of assembled DNA molecules</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">products</span> <span class="o">=</span> <span class="n">gibson_assembly</span><span class="p">(</span><span class="n">frags</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_recast_sources</span><span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="n">InFusionSource</span><span class="p">)</span></div>



<div class="viewcode-block" id="fusion_pcr_assembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.fusion_pcr_assembly">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fusion_pcr_assembly</span><span class="p">(</span>
    <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span> <span class="n">circular_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products for fusion PCR assembly. This is the same as Gibson</span>
<span class="sd">    assembly, but with a different name.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frags : list[_Dseqrecord]</span>
<span class="sd">        List of DNA fragments to assemble</span>
<span class="sd">    limit : int, optional</span>
<span class="sd">        Minimum overlap length required, by default 25</span>
<span class="sd">    circular_only : bool, optional</span>
<span class="sd">        If True, only return circular assemblies, by default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of assembled DNA molecules</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">products</span> <span class="o">=</span> <span class="n">gibson_assembly</span><span class="p">(</span><span class="n">frags</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_recast_sources</span><span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="n">OverlapExtensionPCRLigationSource</span><span class="p">)</span></div>



<div class="viewcode-block" id="in_vivo_assembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.in_vivo_assembly">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">in_vivo_assembly</span><span class="p">(</span>
    <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span> <span class="n">circular_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products for in vivo assembly (IVA), which relies on homologous recombination between the fragments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frags : list[_Dseqrecord]</span>
<span class="sd">        List of DNA fragments to assemble</span>
<span class="sd">    limit : int, optional</span>
<span class="sd">        Minimum overlap length required, by default 25</span>
<span class="sd">    circular_only : bool, optional</span>
<span class="sd">        If True, only return circular assemblies, by default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of assembled DNA molecules</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">products</span> <span class="o">=</span> <span class="n">common_function_assembly_products</span><span class="p">(</span>
        <span class="n">frags</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">common_sub_strings</span><span class="p">,</span> <span class="n">circular_only</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_recast_sources</span><span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="n">InVivoAssemblySource</span><span class="p">)</span></div>



<div class="viewcode-block" id="restriction_ligation_assembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.restriction_ligation_assembly">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">restriction_ligation_assembly</span><span class="p">(</span>
    <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
    <span class="n">enzymes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;_AbstractCut&quot;</span><span class="p">],</span>
    <span class="n">allow_blunt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">circular_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products for restriction ligation assembly:</span>

<span class="sd">    - Finds cutsites in the fragments</span>
<span class="sd">    - Finds all products that could be assembled by ligating the fragments based on those cutsites</span>
<span class="sd">    - Will NOT return products that combine an existing end with an end generated by the same enzyme (see example below)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frags : list[_Dseqrecord]</span>
<span class="sd">        List of DNA fragments to assemble</span>
<span class="sd">    enzymes : list[_AbstractCut]</span>
<span class="sd">        List of restriction enzymes to use</span>
<span class="sd">    allow_blunt : bool, optional</span>
<span class="sd">        If True, allow blunt end ligations, by default True</span>
<span class="sd">    circular_only : bool, optional</span>
<span class="sd">        If True, only return circular assemblies, by default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of assembled DNA molecules</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In the example below, we plan to assemble a plasmid from a backbone and an insert, using the EcoRI and SalI enzymes.</span>
<span class="sd">    Note how 2 circular products are returned, one contains the insert (``acgt``)</span>
<span class="sd">    and the desired part of the backbone (``cccccc``), the other contains the</span>
<span class="sd">    reversed insert (``tgga``) and the cut-out part of the backbone (``aaa``).</span>

<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import restriction_ligation_assembly</span>
<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from Bio.Restriction import EcoRI, SalI</span>
<span class="sd">    &gt;&gt;&gt; backbone = Dseqrecord(&quot;cccGAATTCaaaGTCGACccc&quot;, circular=True)</span>
<span class="sd">    &gt;&gt;&gt; insert = Dseqrecord(&quot;ggGAATTCaggtGTCGACgg&quot;)</span>
<span class="sd">    &gt;&gt;&gt; products = restriction_ligation_assembly([backbone, insert], [EcoRI, SalI], circular_only=True)</span>
<span class="sd">    &gt;&gt;&gt; products[0].seq</span>
<span class="sd">    Dseq(o22)</span>
<span class="sd">    TCGACccccccGAATTCaggtG</span>
<span class="sd">    AGCTGggggggCTTAAGtccaC</span>
<span class="sd">    &gt;&gt;&gt; products[1].seq</span>
<span class="sd">    Dseq(o19)</span>
<span class="sd">    AATTCaaaGTCGACacctG</span>
<span class="sd">    TTAAGtttCAGCTGtggaC</span>

<span class="sd">    Note that passing a pre-cut fragment will not work.</span>

<span class="sd">    &gt;&gt;&gt; restriction_products = insert.cut([EcoRI, SalI])</span>
<span class="sd">    &gt;&gt;&gt; cut_insert = restriction_products[1]</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_assembly([backbone, cut_insert], [EcoRI, SalI], circular_only=True)</span>
<span class="sd">    []</span>

<span class="sd">    It also works with a single fragment, for circularization:</span>

<span class="sd">    &gt;&gt;&gt; seq = Dseqrecord(&quot;GAATTCaaaGAATTC&quot;)</span>
<span class="sd">    &gt;&gt;&gt; products =restriction_ligation_assembly([seq], [EcoRI])</span>
<span class="sd">    &gt;&gt;&gt; products[0].seq</span>
<span class="sd">    Dseq(o9)</span>
<span class="sd">    AATTCaaaG</span>
<span class="sd">    TTAAGtttC</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">algorithm_fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_l</span><span class="p">):</span>
        <span class="c1"># By default, we allow blunt ends</span>
        <span class="k">return</span> <span class="n">restriction_ligation_overlap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">enzymes</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">allow_blunt</span><span class="p">)</span>

    <span class="n">products</span> <span class="o">=</span> <span class="n">common_function_assembly_products</span><span class="p">(</span>
        <span class="n">frags</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">algorithm_fn</span><span class="p">,</span> <span class="n">circular_only</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_recast_sources</span><span class="p">(</span>
        <span class="n">products</span><span class="p">,</span> <span class="n">RestrictionAndLigationSource</span><span class="p">,</span> <span class="n">restriction_enzymes</span><span class="o">=</span><span class="n">enzymes</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="golden_gate_assembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.golden_gate_assembly">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">golden_gate_assembly</span><span class="p">(</span>
    <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
    <span class="n">enzymes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;_AbstractCut&quot;</span><span class="p">],</span>
    <span class="n">allow_blunt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">circular_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products for Golden Gate assembly. This is the same as</span>
<span class="sd">    restriction ligation assembly, but with a different name. Check the documentation</span>
<span class="sd">    for ``restriction_ligation_assembly`` for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frags : list[_Dseqrecord]</span>
<span class="sd">        List of DNA fragments to assemble</span>
<span class="sd">    enzymes : list[_AbstractCut]</span>
<span class="sd">        List of restriction enzymes to use</span>
<span class="sd">    allow_blunt : bool, optional</span>
<span class="sd">        If True, allow blunt end ligations, by default True</span>
<span class="sd">    circular_only : bool, optional</span>
<span class="sd">        If True, only return circular assemblies, by default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of assembled DNA molecules</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    See the example for ``restriction_ligation_assembly``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">restriction_ligation_assembly</span><span class="p">(</span><span class="n">frags</span><span class="p">,</span> <span class="n">enzymes</span><span class="p">,</span> <span class="n">allow_blunt</span><span class="p">,</span> <span class="n">circular_only</span><span class="p">)</span></div>



<div class="viewcode-block" id="ligation_assembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.ligation_assembly">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ligation_assembly</span><span class="p">(</span>
    <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
    <span class="n">allow_blunt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">allow_partial_overlap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">circular_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products for ligation assembly, as inputs pass the fragments (digested if needed) that</span>
<span class="sd">    will be ligated.</span>

<span class="sd">    For most cases, you probably should use ``restriction_ligation_assembly`` instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frags : list[_Dseqrecord]</span>
<span class="sd">        List of DNA fragments to assemble</span>
<span class="sd">    allow_blunt : bool, optional</span>
<span class="sd">        If True, allow blunt end ligations, by default False</span>
<span class="sd">    allow_partial_overlap : bool, optional</span>
<span class="sd">        If True, allow partial overlaps between sticky ends, by default False</span>
<span class="sd">    circular_only : bool, optional</span>
<span class="sd">        If True, only return circular assemblies, by default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of assembled DNA molecules</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In the example below, we plan to assemble a plasmid from a backbone and an insert,</span>
<span class="sd">    using the EcoRI enzyme. The insert and insertion site in the backbone are flanked by</span>
<span class="sd">    EcoRI sites, so there are two possible products depending on the orientation of the insert.</span>

<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import ligation_assembly</span>
<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from Bio.Restriction import EcoRI</span>
<span class="sd">    &gt;&gt;&gt; backbone = Dseqrecord(&quot;cccGAATTCaaaGAATTCccc&quot;, circular=True)</span>
<span class="sd">    &gt;&gt;&gt; backbone_cut = backbone.cut(EcoRI)[1]</span>
<span class="sd">    &gt;&gt;&gt; insert = Dseqrecord(&quot;ggGAATTCaggtGAATTCgg&quot;)</span>
<span class="sd">    &gt;&gt;&gt; insert_cut = insert.cut(EcoRI)[1]</span>
<span class="sd">    &gt;&gt;&gt; products = ligation_assembly([backbone_cut, insert_cut])</span>
<span class="sd">    &gt;&gt;&gt; products[0].seq</span>
<span class="sd">    Dseq(o22)</span>
<span class="sd">    AATTCccccccGAATTCaggtG</span>
<span class="sd">    TTAAGggggggCTTAAGtccaC</span>
<span class="sd">    &gt;&gt;&gt; products[1].seq</span>
<span class="sd">    Dseq(o22)</span>
<span class="sd">    AATTCccccccGAATTCacctG</span>
<span class="sd">    TTAAGggggggCTTAAGtggaC</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">sticky_end_algorithm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_l</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sticky_end_sub_strings</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">allow_partial_overlap</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">allow_blunt</span><span class="p">:</span>
        <span class="n">algorithm_fn</span> <span class="o">=</span> <span class="n">combine_algorithms</span><span class="p">(</span><span class="n">sticky_end_algorithm</span><span class="p">,</span> <span class="n">blunt_overlap</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">algorithm_fn</span> <span class="o">=</span> <span class="n">sticky_end_algorithm</span>

    <span class="n">products</span> <span class="o">=</span> <span class="n">common_function_assembly_products</span><span class="p">(</span>
        <span class="n">frags</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">algorithm_fn</span><span class="p">,</span> <span class="n">circular_only</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_recast_sources</span><span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="n">LigationSource</span><span class="p">)</span></div>



<div class="viewcode-block" id="assembly_is_multi_site">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.assembly_is_multi_site">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assembly_is_multi_site</span><span class="p">(</span><span class="n">asm</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns True if the assembly is a multi-site assembly, False otherwise.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">is_cycle</span> <span class="o">=</span> <span class="n">asm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">asm</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">asm2</span> <span class="o">=</span> <span class="n">edge_representation2subfragment_representation</span><span class="p">(</span><span class="n">asm</span><span class="p">,</span> <span class="n">is_cycle</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">asm2</span><span class="p">)</span></div>



<div class="viewcode-block" id="gateway_assembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.gateway_assembly">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gateway_assembly</span><span class="p">(</span>
    <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
    <span class="n">reaction_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;BP&quot;</span><span class="p">,</span> <span class="s2">&quot;LR&quot;</span><span class="p">],</span>
    <span class="n">greedy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">circular_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">multi_site_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products for Gateway assembly / Gateway cloning.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frags : list[_Dseqrecord]</span>
<span class="sd">        List of DNA fragments to assemble</span>
<span class="sd">    reaction_type : Literal[&#39;BP&#39;, &#39;LR&#39;]</span>
<span class="sd">        Type of Gateway reaction</span>
<span class="sd">    greedy : bool, optional</span>
<span class="sd">        If True, use greedy gateway consensus sites, by default False</span>
<span class="sd">    circular_only : bool, optional</span>
<span class="sd">        If True, only return circular assemblies, by default False</span>
<span class="sd">    multi_site_only : bool, optional</span>
<span class="sd">        If True, only return products that where 2 sites recombined. Even if input sequences</span>
<span class="sd">        contain multiple att sites (typically 2), a product could be generated where only one</span>
<span class="sd">        site recombines. That&#39;s typically not what you want, so you can set this to True to</span>
<span class="sd">        only return products where both att sites recombined.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of assembled DNA molecules</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Below an example with dummy Gateway sequences, composed with minimal sequences and the consensus</span>
<span class="sd">    att sites.</span>

<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import gateway_assembly</span>
<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; attB1 = &quot;ACAACTTTGTACAAAAAAGCAGAAG&quot;</span>
<span class="sd">    &gt;&gt;&gt; attP1 = &quot;AAAATAATGATTTTATTTGACTGATAGTGACCTGTTCGTTGCAACAAATTGATGAGCAATGCTTTTTTATAATGCCAACTTTGTACAAAAAAGCTGAACGAGAAGCGTAAAATGATATAAATATCAATATATTAAATTAGATTTTGCATAAAAAACAGACTACATAATACTGTAAAACACAACATATCCAGTCACTATGAATCAACTACTTAGATGGTATTAGTGACCTGTA&quot;</span>
<span class="sd">    &gt;&gt;&gt; attR1 = &quot;ACAACTTTGTACAAAAAAGCTGAACGAGAAACGTAAAATGATATAAATATCAATATATTAAATTAGATTTTGCATAAAAAACAGACTACATAATACTGTAAAACACAACATATGCAGTCACTATG&quot;</span>
<span class="sd">    &gt;&gt;&gt; attL1 = &quot;CAAATAATGATTTTATTTTGACTGATAGTGACCTGTTCGTTGCAACAAATTGATAAGCAATGCTTTCTTATAATGCCAACTTTGTACAAAAAAGCAGGCT&quot;</span>
<span class="sd">    &gt;&gt;&gt; seq1 = Dseqrecord(&quot;aaa&quot; + attB1 + &quot;ccc&quot;)</span>
<span class="sd">    &gt;&gt;&gt; seq2 = Dseqrecord(&quot;aaa&quot; + attP1 + &quot;ccc&quot;)</span>
<span class="sd">    &gt;&gt;&gt; seq3 = Dseqrecord(&quot;aaa&quot; + attR1 + &quot;ccc&quot;)</span>
<span class="sd">    &gt;&gt;&gt; seq4 = Dseqrecord(&quot;aaa&quot; + attL1 + &quot;ccc&quot;)</span>
<span class="sd">    &gt;&gt;&gt; products_BP = gateway_assembly([seq1, seq2], &quot;BP&quot;)</span>
<span class="sd">    &gt;&gt;&gt; products_LR = gateway_assembly([seq3, seq4], &quot;LR&quot;)</span>
<span class="sd">    &gt;&gt;&gt; len(products_BP)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; len(products_LR)</span>
<span class="sd">    2</span>

<span class="sd">    Now let&#39;s understand the ``multi_site_only`` parameter. Let&#39;s consider a case where we are swapping fragments</span>
<span class="sd">    between two plasmids using an LR reaction. Experimentally, we expect to obtain two plasmids, resulting from the</span>
<span class="sd">    swapping between the two att sites. That&#39;s what we get if we set ``multi_site_only`` to True.</span>

<span class="sd">    &gt;&gt;&gt; attL2 = &#39;aaataatgattttattttgactgatagtgacctgttcgttgcaacaaattgataagcaatgctttcttataatgccaactttgtacaagaaagctg&#39;</span>
<span class="sd">    &gt;&gt;&gt; attR2 = &#39;accactttgtacaagaaagctgaacgagaaacgtaaaatgatataaatatcaatatattaaattagattttgcataaaaaacagactacataatactgtaaaacacaacatatccagtcactatg&#39;</span>
<span class="sd">    &gt;&gt;&gt; insert = Dseqrecord(&quot;cccccc&quot; + attL1 + &quot;ccc&quot; + attL2 + &quot;cccccc&quot;, circular=True)</span>
<span class="sd">    &gt;&gt;&gt; backbone = Dseqrecord(&quot;ttttt&quot; + attR1 + &quot;aaa&quot; + attR2, circular=True)</span>
<span class="sd">    &gt;&gt;&gt; products = gateway_assembly([insert, backbone], &quot;LR&quot;, multi_site_only=True)</span>
<span class="sd">    &gt;&gt;&gt; len(products)</span>
<span class="sd">    2</span>

<span class="sd">    However, if we set ``multi_site_only`` to False, we get 4 products, which also include the intermediate products</span>
<span class="sd">    where the two plasmids are combined into a single one through recombination of a single att site. This is an</span>
<span class="sd">    intermediate of the reaction, and typically we don&#39;t want it:</span>

<span class="sd">    &gt;&gt;&gt; products = gateway_assembly([insert, backbone], &quot;LR&quot;, multi_site_only=False)</span>
<span class="sd">    &gt;&gt;&gt; print([len(p) for p in products])</span>
<span class="sd">    [469, 237, 232, 469]</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">reaction_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;BP&quot;</span><span class="p">,</span> <span class="s2">&quot;LR&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Invalid reaction type: </span><span class="si">{</span><span class="n">reaction_type</span><span class="si">}</span><span class="s2">, can only be BP or LR&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">algorithm_fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_l</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">gateway_overlap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reaction_type</span><span class="p">,</span> <span class="n">greedy</span><span class="p">)</span>

    <span class="n">filter_results_function</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">multi_site_only</span> <span class="k">else</span> <span class="n">assembly_is_multi_site</span>

    <span class="n">products</span> <span class="o">=</span> <span class="n">common_function_assembly_products</span><span class="p">(</span>
        <span class="n">frags</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">algorithm_fn</span><span class="p">,</span> <span class="n">circular_only</span><span class="p">,</span> <span class="n">filter_results_function</span>
    <span class="p">)</span>
    <span class="n">products</span> <span class="o">=</span> <span class="n">_recast_sources</span><span class="p">(</span>
        <span class="n">products</span><span class="p">,</span>
        <span class="n">GatewaySource</span><span class="p">,</span>
        <span class="n">reaction_type</span><span class="o">=</span><span class="n">reaction_type</span><span class="p">,</span>
        <span class="n">greedy</span><span class="o">=</span><span class="n">greedy</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">products</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Build a list of all the sites in the fragments</span>
        <span class="n">sites_in_fragments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">frags</span><span class="p">:</span>
            <span class="n">sites_in_fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">find_gateway_sites</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">greedy</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">formatted_strings</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s1">&#39;fragment </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sites</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sites_in_fragments</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Inputs are not compatible for </span><span class="si">{</span><span class="n">reaction_type</span><span class="si">}</span><span class="s2"> reaction.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formatted_strings</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">products</span></div>



<div class="viewcode-block" id="common_function_integration_products">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.common_function_integration_products">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">common_function_integration_products</span><span class="p">(</span>
    <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">:</span> <span class="n">Callable</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Common function to avoid code duplication for integration products.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frags : list[_Dseqrecord]</span>
<span class="sd">        List of DNA fragments to integrate</span>
<span class="sd">    limit : int or None</span>
<span class="sd">        Minimum overlap length required, or None if not applicable</span>
<span class="sd">    algorithm : Callable</span>
<span class="sd">        Function that determines valid overlaps between fragments</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of integrated DNA molecules</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">asm</span> <span class="o">=</span> <span class="n">SingleFragmentAssembly</span><span class="p">(</span><span class="n">frags</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">asm</span> <span class="o">=</span> <span class="n">Assembly</span><span class="p">(</span>
            <span class="n">frags</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">use_fragment_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_all_fragments</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Genome must be linear for integration assembly, use in vivo assembly instead&quot;</span>
        <span class="p">)</span>

    <span class="c1"># We only want insertions in the genome (first fragment)</span>
    <span class="n">output_assemblies</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">asm</span><span class="o">.</span><span class="n">get_insertion_assemblies</span><span class="p">()</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">assemble</span><span class="p">(</span><span class="n">frags</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">output_assemblies</span><span class="p">]</span></div>



<div class="viewcode-block" id="common_handle_insertion_fragments">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.common_handle_insertion_fragments">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">common_handle_insertion_fragments</span><span class="p">(</span>
    <span class="n">genome</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">inserts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Common function to handle / validate insertion fragments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    genome : _Dseqrecord</span>
<span class="sd">        Target genome sequence</span>
<span class="sd">    inserts : list[_Dseqrecord] or _Dseqrecord</span>
<span class="sd">        DNA fragment(s) to insert</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List containing genome and insert fragments</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">genome</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Genome must be a Dseqrecord object&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inserts</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">inserts</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Inserts must be a list of Dseqrecord objects&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inserts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Inserts must be a non-empty list of Dseqrecord objects&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">genome</span><span class="p">]</span> <span class="o">+</span> <span class="n">inserts</span></div>



<div class="viewcode-block" id="common_function_excision_products">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.common_function_excision_products">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">common_function_excision_products</span><span class="p">(</span>
    <span class="n">genome</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">:</span> <span class="n">Callable</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Common function to avoid code duplication for excision products.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    genome : _Dseqrecord</span>
<span class="sd">        Target genome sequence</span>
<span class="sd">    limit : int or None</span>
<span class="sd">        Minimum overlap length required, or None if not applicable</span>
<span class="sd">    algorithm : Callable</span>
<span class="sd">        Function that determines valid overlaps between fragments</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of excised DNA molecules</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">asm</span> <span class="o">=</span> <span class="n">SingleFragmentAssembly</span><span class="p">([</span><span class="n">genome</span><span class="p">],</span> <span class="n">limit</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">asm</span><span class="o">.</span><span class="n">assemble_circular</span><span class="p">()</span> <span class="o">+</span> <span class="n">asm</span><span class="o">.</span><span class="n">assemble_insertion</span><span class="p">()</span></div>



<div class="viewcode-block" id="homologous_recombination_integration">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.homologous_recombination_integration">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">homologous_recombination_integration</span><span class="p">(</span>
    <span class="n">genome</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span>
    <span class="n">inserts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
    <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products resulting from the integration of an insert (or inserts joined</span>
<span class="sd">    through in vivo recombination) into the genome through homologous recombination.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    genome : _Dseqrecord</span>
<span class="sd">        Target genome sequence</span>
<span class="sd">    inserts : list[_Dseqrecord]</span>
<span class="sd">        DNA fragment(s) to insert</span>
<span class="sd">    limit : int, optional</span>
<span class="sd">        Minimum homology length required, by default 40</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of integrated DNA molecules</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Below an example with a single insert.</span>

<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import homologous_recombination_integration</span>
<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; homology = &quot;AAGTCCGTTCGTTTTACCTG&quot;</span>
<span class="sd">    &gt;&gt;&gt; genome = Dseqrecord(f&quot;aaaaaa{homology}ccccc{homology}aaaaaa&quot;)</span>
<span class="sd">    &gt;&gt;&gt; insert = Dseqrecord(f&quot;{homology}gggg{homology}&quot;)</span>
<span class="sd">    &gt;&gt;&gt; products = homologous_recombination_integration(genome, [insert], 20)</span>
<span class="sd">    &gt;&gt;&gt; str(products[0].seq)</span>
<span class="sd">    &#39;aaaaaaAAGTCCGTTCGTTTTACCTGggggAAGTCCGTTCGTTTTACCTGaaaaaa&#39;</span>

<span class="sd">    Below an example with two inserts joined through homology.</span>

<span class="sd">    &gt;&gt;&gt; homology2 = &quot;ATTACAGCATGGGAAGAAAGA&quot;</span>
<span class="sd">    &gt;&gt;&gt; insert_1 = Dseqrecord(f&quot;{homology}gggg{homology2}&quot;)</span>
<span class="sd">    &gt;&gt;&gt; insert_2 = Dseqrecord(f&quot;{homology2}cccc{homology}&quot;)</span>
<span class="sd">    &gt;&gt;&gt; products = homologous_recombination_integration(genome, [insert_1, insert_2], 20)</span>
<span class="sd">    &gt;&gt;&gt; str(products[0].seq)</span>
<span class="sd">    &#39;aaaaaaAAGTCCGTTCGTTTTACCTGggggATTACAGCATGGGAAGAAAGAccccAAGTCCGTTCGTTTTACCTGaaaaaa&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fragments</span> <span class="o">=</span> <span class="n">common_handle_insertion_fragments</span><span class="p">(</span><span class="n">genome</span><span class="p">,</span> <span class="n">inserts</span><span class="p">)</span>

    <span class="n">products</span> <span class="o">=</span> <span class="n">common_function_integration_products</span><span class="p">(</span>
        <span class="n">fragments</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">common_sub_strings</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_recast_sources</span><span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="n">HomologousRecombinationSource</span><span class="p">)</span></div>



<div class="viewcode-block" id="homologous_recombination_excision">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.homologous_recombination_excision">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">homologous_recombination_excision</span><span class="p">(</span>
    <span class="n">genome</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products resulting from the excision of a fragment from the genome through</span>
<span class="sd">    homologous recombination.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    genome : _Dseqrecord</span>
<span class="sd">        Target genome sequence</span>
<span class="sd">    limit : int, optional</span>
<span class="sd">        Minimum homology length required, by default 40</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List containing excised plasmid and remaining genome sequence</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Example of a homologous recombination event, where a plasmid is excised from the</span>
<span class="sd">    genome (circular sequence of 25 bp), and that part is removed from the genome,</span>
<span class="sd">    leaving a shorter linear sequence (32 bp).</span>

<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import homologous_recombination_excision</span>
<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; homology = &quot;AAGTCCGTTCGTTTTACCTG&quot;</span>
<span class="sd">    &gt;&gt;&gt; genome = Dseqrecord(f&quot;aaaaaa{homology}ccccc{homology}aaaaaa&quot;)</span>
<span class="sd">    &gt;&gt;&gt; products = homologous_recombination_excision(genome, 20)</span>
<span class="sd">    &gt;&gt;&gt; products</span>
<span class="sd">    [Dseqrecord(o25), Dseqrecord(-32)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">products</span> <span class="o">=</span> <span class="n">common_function_excision_products</span><span class="p">(</span><span class="n">genome</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">common_sub_strings</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_recast_sources</span><span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="n">HomologousRecombinationSource</span><span class="p">)</span></div>



<div class="viewcode-block" id="cre_lox_integration">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.cre_lox_integration">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cre_lox_integration</span><span class="p">(</span>
    <span class="n">genome</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">inserts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products resulting from the integration of an insert (or inserts joined</span>
<span class="sd">    through cre-lox recombination among them) into the genome through cre-lox integration.</span>

<span class="sd">    Also works with lox66 and lox71 (see ``pydna.cre_lox`` for more details).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    genome : _Dseqrecord</span>
<span class="sd">        Target genome sequence</span>
<span class="sd">    inserts : list[_Dseqrecord] or _Dseqrecord</span>
<span class="sd">        DNA fragment(s) to insert</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of integrated DNA molecules</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Below an example of reversible integration and excision.</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import cre_lox_integration, cre_lox_excision</span>
<span class="sd">    &gt;&gt;&gt; from pydna.cre_lox import LOXP_SEQUENCE</span>
<span class="sd">    &gt;&gt;&gt; a = Dseqrecord(f&quot;cccccc{LOXP_SEQUENCE}aaaaa&quot;)</span>
<span class="sd">    &gt;&gt;&gt; b = Dseqrecord(f&quot;{LOXP_SEQUENCE}bbbbb&quot;, circular=True)</span>
<span class="sd">    &gt;&gt;&gt; [a, b]</span>
<span class="sd">    [Dseqrecord(-45), Dseqrecord(o39)]</span>
<span class="sd">    &gt;&gt;&gt; res = cre_lox_integration(a, [b])</span>
<span class="sd">    &gt;&gt;&gt; res</span>
<span class="sd">    [Dseqrecord(-84)]</span>
<span class="sd">    &gt;&gt;&gt; res2 = cre_lox_excision(res[0])</span>
<span class="sd">    &gt;&gt;&gt; res2</span>
<span class="sd">    [Dseqrecord(o39), Dseqrecord(-45)]</span>

<span class="sd">    Below an example with lox66 and lox71 (irreversible integration).</span>
<span class="sd">    Here, the result of excision is still returned because there is a low</span>
<span class="sd">    probability of it happening, but it&#39;s considered a rare event.</span>

<span class="sd">    &gt;&gt;&gt; lox66 = &#39;ATAACTTCGTATAGCATACATTATACGAACGGTA&#39;</span>
<span class="sd">    &gt;&gt;&gt; lox71 = &#39;TACCGTTCGTATAGCATACATTATACGAAGTTAT&#39;</span>
<span class="sd">    &gt;&gt;&gt; a = Dseqrecord(f&quot;cccccc{lox66}aaaaa&quot;)</span>
<span class="sd">    &gt;&gt;&gt; b = Dseqrecord(f&quot;{lox71}bbbbb&quot;, circular=True)</span>
<span class="sd">    &gt;&gt;&gt; res = cre_lox_integration(a, [b])</span>
<span class="sd">    &gt;&gt;&gt; res</span>
<span class="sd">    [Dseqrecord(-84)]</span>
<span class="sd">    &gt;&gt;&gt; res2 = cre_lox_excision(res[0])</span>
<span class="sd">    &gt;&gt;&gt; res2</span>
<span class="sd">    [Dseqrecord(o39), Dseqrecord(-45)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fragments</span> <span class="o">=</span> <span class="n">common_handle_insertion_fragments</span><span class="p">(</span><span class="n">genome</span><span class="p">,</span> <span class="n">inserts</span><span class="p">)</span>
    <span class="n">products</span> <span class="o">=</span> <span class="n">common_function_integration_products</span><span class="p">(</span><span class="n">fragments</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cre_loxP_overlap</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_recast_sources</span><span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="n">CreLoxRecombinationSource</span><span class="p">)</span></div>



<div class="viewcode-block" id="cre_lox_excision">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.cre_lox_excision">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cre_lox_excision</span><span class="p">(</span><span class="n">genome</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products for CRE-lox excision.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    genome : _Dseqrecord</span>
<span class="sd">        Target genome sequence</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List containing excised plasmid and remaining genome sequence</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Below an example of reversible integration and excision.</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import cre_lox_integration, cre_lox_excision</span>
<span class="sd">    &gt;&gt;&gt; from pydna.cre_lox import LOXP_SEQUENCE</span>
<span class="sd">    &gt;&gt;&gt; a = Dseqrecord(f&quot;cccccc{LOXP_SEQUENCE}aaaaa&quot;)</span>
<span class="sd">    &gt;&gt;&gt; b = Dseqrecord(f&quot;{LOXP_SEQUENCE}bbbbb&quot;, circular=True)</span>
<span class="sd">    &gt;&gt;&gt; [a, b]</span>
<span class="sd">    [Dseqrecord(-45), Dseqrecord(o39)]</span>
<span class="sd">    &gt;&gt;&gt; res = cre_lox_integration(a, [b])</span>
<span class="sd">    &gt;&gt;&gt; res</span>
<span class="sd">    [Dseqrecord(-84)]</span>
<span class="sd">    &gt;&gt;&gt; res2 = cre_lox_excision(res[0])</span>
<span class="sd">    &gt;&gt;&gt; res2</span>
<span class="sd">    [Dseqrecord(o39), Dseqrecord(-45)]</span>

<span class="sd">    Below an example with lox66 and lox71 (irreversible integration).</span>
<span class="sd">    Here, the result of excision is still returned because there is a low</span>
<span class="sd">    probability of it happening, but it&#39;s considered a rare event.</span>

<span class="sd">    &gt;&gt;&gt; lox66 = &#39;ATAACTTCGTATAGCATACATTATACGAACGGTA&#39;</span>
<span class="sd">    &gt;&gt;&gt; lox71 = &#39;TACCGTTCGTATAGCATACATTATACGAAGTTAT&#39;</span>
<span class="sd">    &gt;&gt;&gt; a = Dseqrecord(f&quot;cccccc{lox66}aaaaa&quot;)</span>
<span class="sd">    &gt;&gt;&gt; b = Dseqrecord(f&quot;{lox71}bbbbb&quot;, circular=True)</span>
<span class="sd">    &gt;&gt;&gt; res = cre_lox_integration(a, [b])</span>
<span class="sd">    &gt;&gt;&gt; res</span>
<span class="sd">    [Dseqrecord(-84)]</span>
<span class="sd">    &gt;&gt;&gt; res2 = cre_lox_excision(res[0])</span>
<span class="sd">    &gt;&gt;&gt; res2</span>
<span class="sd">    [Dseqrecord(o39), Dseqrecord(-45)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">products</span> <span class="o">=</span> <span class="n">common_function_excision_products</span><span class="p">(</span><span class="n">genome</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cre_loxP_overlap</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_recast_sources</span><span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="n">CreLoxRecombinationSource</span><span class="p">)</span></div>



<div class="viewcode-block" id="crispr_integration">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.crispr_integration">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">crispr_integration</span><span class="p">(</span>
    <span class="n">genome</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span>
    <span class="n">inserts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
    <span class="n">guides</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Primer</span><span class="p">],</span>
    <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the products for CRISPR integration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    genome : _Dseqrecord</span>
<span class="sd">        Target genome sequence</span>
<span class="sd">    inserts : list[_Dseqrecord]</span>
<span class="sd">        DNA fragment(s) to insert</span>
<span class="sd">    guides : list[_Primer]</span>
<span class="sd">        List of guide RNAs as Primer objects. This may change in the future.</span>
<span class="sd">    limit : int, optional</span>
<span class="sd">        Minimum overlap length required, by default 40</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of integrated DNA molecules</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import crispr_integration</span>
<span class="sd">    &gt;&gt;&gt; from pydna.primer import Primer</span>
<span class="sd">    &gt;&gt;&gt; genome = Dseqrecord(&quot;aaccggttcaatgcaaacagtaatgatggatgacattcaaagcac&quot;, name=&quot;genome&quot;)</span>
<span class="sd">    &gt;&gt;&gt; insert = Dseqrecord(&quot;aaccggttAAAAAAAAAttcaaagcac&quot;, name=&quot;insert&quot;)</span>
<span class="sd">    &gt;&gt;&gt; guide = Primer(&quot;ttcaatgcaaacagtaatga&quot;, name=&quot;guide&quot;)</span>
<span class="sd">    &gt;&gt;&gt; product, *_ = crispr_integration(genome, [insert], [guide], 8)</span>
<span class="sd">    &gt;&gt;&gt; product</span>
<span class="sd">    Dseqrecord(-27)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">guides</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one guide RNA is required for CRISPR integration&quot;</span><span class="p">)</span>

    <span class="c1"># Get all the possible products from the homologous recombination integration</span>
    <span class="n">products</span> <span class="o">=</span> <span class="n">homologous_recombination_integration</span><span class="p">(</span><span class="n">genome</span><span class="p">,</span> <span class="n">inserts</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

    <span class="c1"># Verify that the guides cut in the region that will be repaired</span>

    <span class="c1"># First we collect the positions where the guides cut</span>
    <span class="n">guide_cuts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">guide</span> <span class="ow">in</span> <span class="n">guides</span><span class="p">:</span>
        <span class="n">enzyme</span> <span class="o">=</span> <span class="n">cas9</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">guide</span><span class="o">.</span><span class="n">seq</span><span class="p">))</span>
        <span class="n">possible_cuts</span> <span class="o">=</span> <span class="n">genome</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">get_cutsites</span><span class="p">(</span><span class="n">enzyme</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_cuts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Could not find Cas9 cutsite in the target sequence using the guide: </span><span class="si">{</span><span class="n">guide</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Keep only the position of the cut</span>
        <span class="n">possible_cuts</span> <span class="o">=</span> <span class="p">[</span><span class="n">cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">cut</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">possible_cuts</span><span class="p">]</span>
        <span class="n">guide_cuts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">possible_cuts</span><span class="p">)</span>

    <span class="c1"># Then, we check it the possible homologous recombination products contain the cuts</span>
    <span class="c1"># from the guides inside the repair region.</span>
    <span class="c1"># We also add the used guides to each product. This is very important!</span>
    <span class="n">valid_products</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">product</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">products</span><span class="p">):</span>
        <span class="c1"># The second element of product.source.input is conventionally the insert/repair fragment</span>
        <span class="c1"># The other two (first and third) are the two bits of the genome</span>
        <span class="n">repair_start</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">product</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">right_location</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Here we do +1 because the position of the cut marks the boundary (e.g. 0:10, 10:20 if a cut is at pos 10)</span>
        <span class="n">repair_end</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">product</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">left_location</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">repair_location</span> <span class="o">=</span> <span class="n">create_location</span><span class="p">(</span><span class="n">repair_start</span><span class="p">,</span> <span class="n">repair_end</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">genome</span><span class="p">))</span>
        <span class="n">some_cuts_inside_repair</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_cuts_inside_repair</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cut_group</span> <span class="ow">in</span> <span class="n">guide_cuts</span><span class="p">:</span>
            <span class="n">cuts_in_repair</span> <span class="o">=</span> <span class="p">[</span><span class="n">cut</span> <span class="k">for</span> <span class="n">cut</span> <span class="ow">in</span> <span class="n">cut_group</span> <span class="k">if</span> <span class="n">cut</span> <span class="ow">in</span> <span class="n">repair_location</span><span class="p">]</span>
            <span class="n">some_cuts_inside_repair</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cuts_in_repair</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">all_cuts_inside_repair</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cuts_in_repair</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cut_group</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">some_cuts_inside_repair</span><span class="p">):</span>
            <span class="n">used_guides</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">guides</span><span class="p">)</span> <span class="k">if</span> <span class="n">all_cuts_inside_repair</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="c1"># Add the used guides to the product &lt;----- VERY IMPORTANT!</span>
            <span class="n">product</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">SourceInput</span><span class="p">(</span><span class="n">sequence</span><span class="o">=</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">used_guides</span><span class="p">])</span>
            <span class="n">valid_products</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">all_cuts_inside_repair</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Some guides cut outside the repair region, please check the guides&quot;</span>
                <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_products</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">products</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Some recombination products were discarded because they had off-target cuts&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">_recast_sources</span><span class="p">(</span><span class="n">valid_products</span><span class="p">,</span> <span class="n">CRISPRSource</span><span class="p">)</span></div>



<div class="viewcode-block" id="pcr_assembly">
<a class="viewcode-back" href="../../reference/pydna.html#pydna.assembly2.pcr_assembly">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pcr_assembly</span><span class="p">(</span>
    <span class="n">template</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span>
    <span class="n">fwd_primer</span><span class="p">:</span> <span class="n">_Primer</span><span class="p">,</span>
    <span class="n">rvs_primer</span><span class="p">:</span> <span class="n">_Primer</span><span class="p">,</span>
    <span class="n">add_primer_features</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
    <span class="n">mismatches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the products for PCR assembly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    template : _Dseqrecord</span>
<span class="sd">        Template sequence</span>
<span class="sd">    fwd_primer : _Primer</span>
<span class="sd">        Forward primer</span>
<span class="sd">    rvs_primer : _Primer</span>
<span class="sd">        Reverse primer</span>
<span class="sd">    add_primer_features : bool, optional</span>
<span class="sd">        If True, add primer features to the product, by default False</span>
<span class="sd">    limit : int, optional</span>
<span class="sd">        Minimum overlap length required, by default 14</span>
<span class="sd">    mismatches : int, optional</span>
<span class="sd">        Maximum number of mismatches, by default 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[_Dseqrecord]</span>
<span class="sd">        List of assembled DNA molecules</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">minimal_annealing</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">+</span> <span class="n">mismatches</span>
    <span class="n">fragments</span> <span class="o">=</span> <span class="p">[</span><span class="n">fwd_primer</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">rvs_primer</span><span class="p">]</span>
    <span class="n">asm</span> <span class="o">=</span> <span class="n">PCRAssembly</span><span class="p">(</span>
        <span class="n">fragments</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="n">minimal_annealing</span><span class="p">,</span>
        <span class="n">mismatches</span><span class="o">=</span><span class="n">mismatches</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">products</span> <span class="o">=</span> <span class="n">asm</span><span class="o">.</span><span class="n">assemble_linear</span><span class="p">()</span>
    <span class="c1"># If both primers are the same, remove duplicates</span>
    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">fwd_primer</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">rvs_primer</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
        <span class="n">products</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">products</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complemented</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">add_primer_features</span><span class="p">:</span>
        <span class="n">products</span> <span class="o">=</span> <span class="p">[</span><span class="n">annotate_primer_binding_sites</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">fragments</span><span class="p">)</span> <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">products</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">_recast_sources</span><span class="p">(</span><span class="n">products</span><span class="p">,</span> <span class="n">PCRSource</span><span class="p">,</span> <span class="n">add_primer_features</span><span class="o">=</span><span class="n">add_primer_features</span><span class="p">)</span></div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Bjrn F. Johansson
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
       Copyright 2024, Bjrn F. Johansson.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>