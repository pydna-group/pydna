

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydna.assembly2 &mdash; pydna 6.0.0a24.post17+b7b559bd66 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=a051be83" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=d848064a"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pydna
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Pydna</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/index.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example_gallery.html">Example gallery</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pydna</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../pydna.html">pydna</a></li>
      <li class="breadcrumb-item active">pydna.assembly2</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pydna.assembly2</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Slightly different assembly implementation&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_itertools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Bio.SeqFeature</span><span class="w"> </span><span class="kn">import</span> <span class="n">SimpleLocation</span><span class="p">,</span> <span class="n">Location</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Bio.Seq</span><span class="w"> </span><span class="kn">import</span> <span class="n">reverse_complement</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Bio.Restriction.Restriction</span><span class="w"> </span><span class="kn">import</span> <span class="n">RestrictionBatch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">regex</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">shift_location</span> <span class="k">as</span> <span class="n">_shift_location</span><span class="p">,</span>
    <span class="n">flatten</span><span class="p">,</span>
    <span class="n">location_boundaries</span> <span class="k">as</span> <span class="n">_location_boundaries</span><span class="p">,</span>
    <span class="n">locations_overlap</span> <span class="k">as</span> <span class="n">_locations_overlap</span><span class="p">,</span>
    <span class="n">sum_is_sticky</span><span class="p">,</span>
    <span class="n">limit_iterator</span><span class="p">,</span>
    <span class="n">create_location</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna._pretty</span><span class="w"> </span><span class="kn">import</span> <span class="n">pretty_str</span> <span class="k">as</span> <span class="n">_pretty_str</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.common_sub_strings</span><span class="w"> </span><span class="kn">import</span> <span class="n">common_sub_strings</span> <span class="k">as</span> <span class="n">common_sub_strings_str</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.dseqrecord</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dseqrecord</span> <span class="k">as</span> <span class="n">_Dseqrecord</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.dseq</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dseq</span> <span class="k">as</span> <span class="n">_Dseq</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.primer</span><span class="w"> </span><span class="kn">import</span> <span class="n">Primer</span> <span class="k">as</span> <span class="n">_Primer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.seqrecord</span><span class="w"> </span><span class="kn">import</span> <span class="n">SeqRecord</span> <span class="k">as</span> <span class="n">_SeqRecord</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydna.types</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">CutSiteType</span><span class="p">,</span>
    <span class="n">EdgeRepresentationAssembly</span><span class="p">,</span>
    <span class="n">SubFragmentRepresentationAssembly</span><span class="p">,</span>
    <span class="n">AssemblyAlgorithmType</span><span class="p">,</span>
    <span class="n">SequenceOverlap</span><span class="p">,</span>
    <span class="n">AssemblyEdgeType</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="gather_overlapping_locations">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.gather_overlapping_locations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gather_overlapping_locations</span><span class="p">(</span>
    <span class="n">locs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Location</span><span class="p">],</span> <span class="n">fragment_length</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Location</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turn a list of locations into a list of tuples of those locations, where each tuple contains</span>
<span class="sd">    locations that overlap. For example, if locs = [loc1, loc2, loc3], and loc1 and loc2 overlap,</span>
<span class="sd">    the output will be [(loc1, loc2), (loc3,)].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make a graph with all the locations as nodes</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">locs</span><span class="p">):</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>

    <span class="c1"># Add edges between nodes that overlap</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">locs</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">_locations_overlap</span><span class="p">(</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">locs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">fragment_length</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

    <span class="c1"># Get groups of overlapping locations</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">loc_set</span> <span class="ow">in</span> <span class="n">_nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loc_set</span><span class="p">))</span>

    <span class="c1"># Sort by location of the first element in each group (does not matter which since they are overlapping)</span>
    <span class="n">groups</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">groups</span></div>



<div class="viewcode-block" id="ends_from_cutsite">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.ends_from_cutsite">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ends_from_cutsite</span><span class="p">(</span>
    <span class="n">cutsite</span><span class="p">:</span> <span class="n">CutSiteType</span><span class="p">,</span> <span class="n">seq</span><span class="p">:</span> <span class="n">_Dseq</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the sticky or blunt ends created by a restriction enzyme cut.</span>

<span class="sd">    Args:</span>
<span class="sd">        cutsite (CutSiteType): A tuple ((cut_watson, ovhg), enzyme) describing where the cut occurs</span>
<span class="sd">        seq (_Dseq): The DNA sequence being cut</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If cutsite is None</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[tuple[str, str], tuple[str, str]]: A tuple of two tuples, each containing the type of end (&#39;5\&#39;&#39;, &#39;3\&#39;&#39;, or &#39;blunt&#39;)</span>
<span class="sd">        and the sequence of the overhang. The first tuple is for the left end, second for the right end.</span>

<span class="sd">    &gt;&gt;&gt; from Bio.Restriction import NotI</span>
<span class="sd">    &gt;&gt;&gt; x = _Dseq(&quot;ctcgGCGGCCGCcagcggccg&quot;)</span>
<span class="sd">    &gt;&gt;&gt; x.get_cutsites(NotI)</span>
<span class="sd">    [((6, -4), NotI)]</span>
<span class="sd">    &gt;&gt;&gt; ends_from_cutsite(x.get_cutsites(NotI)[0], x)</span>
<span class="sd">    ((&quot;5&#39;&quot;, &#39;ggcc&#39;), (&quot;5&#39;&quot;, &#39;ggcc&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">cutsite</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;None is not supported&quot;</span><span class="p">)</span>

    <span class="n">cut_watson</span><span class="p">,</span> <span class="n">cut_crick</span><span class="p">,</span> <span class="n">ovhg</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">get_cut_parameters</span><span class="p">(</span><span class="n">cutsite</span><span class="p">,</span> <span class="n">is_left</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># TODO check the edge in circular</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;5&#39;&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">cut_watson</span><span class="p">:</span><span class="n">cut_crick</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">())</span><span class="o">.</span><span class="n">lower</span><span class="p">()),</span>
            <span class="p">(</span><span class="s2">&quot;5&#39;&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">cut_watson</span><span class="p">:</span><span class="n">cut_crick</span><span class="p">])</span><span class="o">.</span><span class="n">lower</span><span class="p">()),</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">ovhg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;3&#39;&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">cut_crick</span><span class="p">:</span><span class="n">cut_watson</span><span class="p">])</span><span class="o">.</span><span class="n">lower</span><span class="p">()),</span>
            <span class="p">(</span><span class="s2">&quot;3&#39;&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">cut_crick</span><span class="p">:</span><span class="n">cut_watson</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">())</span><span class="o">.</span><span class="n">lower</span><span class="p">()),</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;blunt&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;blunt&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="restriction_ligation_overlap">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.restriction_ligation_overlap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">restriction_ligation_overlap</span><span class="p">(</span>
    <span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span>
    <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span>
    <span class="n">enzymes</span><span class="o">=</span><span class="n">RestrictionBatch</span><span class="p">,</span>
    <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">allow_blunt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">SequenceOverlap</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assembly algorithm to find overlaps that would result from restriction and ligation.</span>

<span class="sd">    Like in sticky and gibson, the order matters (see example below of partial overlap)</span>

<span class="sd">    Args:</span>
<span class="sd">        seqx (_Dseqrecord): The first sequence</span>
<span class="sd">        seqy (_Dseqrecord): The second sequence</span>
<span class="sd">        enzymes (RestrictionBatch): The enzymes to use</span>
<span class="sd">        partial (bool): Whether to allow partial overlaps</span>
<span class="sd">        allow_blunt (bool): Whether to allow blunt ends</span>
<span class="sd">    Returns:</span>
<span class="sd">        list[SequenceOverlap]: A list of overlaps between the two sequences</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import restriction_ligation_overlap</span>
<span class="sd">    &gt;&gt;&gt; from Bio.Restriction import EcoRI, RgaI, DrdI, EcoRV</span>
<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(&quot;ccGAATTCaa&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(&quot;aaaaGAATTCgg&quot;)</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_overlap(x, y, [EcoRI])</span>
<span class="sd">    [(3, 5, 4)]</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_overlap(y, x, [EcoRI])</span>
<span class="sd">    [(5, 3, 4)]</span>

<span class="sd">    Partial overlap, note how it is not symmetric</span>

<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(&quot;GACTAAAGGGTC&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(&quot;AAGCGATCGCAAGCGATCGCAA&quot;)</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_overlap(x, y, [RgaI, DrdI], partial=True)</span>
<span class="sd">    [(6, 5, 1), (6, 15, 1)]</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_overlap(y, x, [RgaI, DrdI], partial=True)</span>
<span class="sd">    []</span>

<span class="sd">    Blunt overlap, returns length of the overlap 0</span>

<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(&quot;aaGATATCcc&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(&quot;ttttGATATCaa&quot;)</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_overlap(x, y, [EcoRV], allow_blunt=True)</span>
<span class="sd">    [(5, 7, 0)]</span>
<span class="sd">    &gt;&gt;&gt; restriction_ligation_overlap(y, x, [EcoRV], allow_blunt=True)</span>
<span class="sd">    [(7, 5, 0)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cuts_x</span> <span class="o">=</span> <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">get_cutsites</span><span class="p">(</span><span class="o">*</span><span class="n">enzymes</span><span class="p">)</span>
    <span class="n">cuts_y</span> <span class="o">=</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">get_cutsites</span><span class="p">(</span><span class="o">*</span><span class="n">enzymes</span><span class="p">)</span>
    <span class="c1"># If blunt ends are allowed, something similar to this could be done to allow</span>
    <span class="c1"># joining with linear sequence ends, but for now it messes up with the only_adjacent_edges</span>
    <span class="c1"># case</span>
    <span class="c1"># if allow_blunt:</span>
    <span class="c1">#     if not seqx.circular:</span>
    <span class="c1">#         cuts_x.append(((len(seqx), 0), None))</span>
    <span class="c1">#     if not seqy.circular:</span>
    <span class="c1">#         cuts_y.append(((0, 0), None))</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cut_x</span><span class="p">,</span> <span class="n">cut_y</span> <span class="ow">in</span> <span class="n">_itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">cuts_x</span><span class="p">,</span> <span class="n">cuts_y</span><span class="p">):</span>
        <span class="c1"># A blunt end</span>
        <span class="k">if</span> <span class="n">allow_blunt</span> <span class="ow">and</span> <span class="n">cut_x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cut_y</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cut_x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cut_y</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">continue</span>

        <span class="c1"># Otherwise, test overhangs</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">sum_is_sticky</span><span class="p">(</span>
            <span class="n">ends_from_cutsite</span><span class="p">(</span><span class="n">cut_x</span><span class="p">,</span> <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">ends_from_cutsite</span><span class="p">(</span><span class="n">cut_y</span><span class="p">,</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">partial</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overlap</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">x_watson</span><span class="p">,</span> <span class="n">x_crick</span><span class="p">,</span> <span class="n">x_ovhg</span> <span class="o">=</span> <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">get_cut_parameters</span><span class="p">(</span><span class="n">cut_x</span><span class="p">,</span> <span class="n">is_left</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">y_watson</span><span class="p">,</span> <span class="n">y_crick</span><span class="p">,</span> <span class="n">y_ovhg</span> <span class="o">=</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">get_cut_parameters</span><span class="p">(</span><span class="n">cut_y</span><span class="p">,</span> <span class="n">is_left</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Positions where the overlap would start for full overlap</span>
        <span class="n">left_x</span> <span class="o">=</span> <span class="n">x_watson</span> <span class="k">if</span> <span class="n">x_ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">x_crick</span>
        <span class="n">left_y</span> <span class="o">=</span> <span class="n">y_watson</span> <span class="k">if</span> <span class="n">y_ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">y_crick</span>

        <span class="c1"># Correct por partial overlaps</span>
        <span class="n">left_x</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x_ovhg</span><span class="p">)</span> <span class="o">-</span> <span class="n">overlap</span>

        <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">left_x</span><span class="p">,</span> <span class="n">left_y</span><span class="p">,</span> <span class="n">overlap</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">matches</span></div>



<div class="viewcode-block" id="combine_algorithms">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.combine_algorithms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">combine_algorithms</span><span class="p">(</span><span class="o">*</span><span class="n">algorithms</span><span class="p">:</span> <span class="n">AssemblyAlgorithmType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AssemblyAlgorithmType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine assembly algorithms, if any of them returns a match, the match is returned.</span>

<span class="sd">    This can be used for example in a ligation where you want to allow both sticky and blunt end ligation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">combined</span><span class="p">(</span><span class="n">seqx</span><span class="p">,</span> <span class="n">seqy</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">algorithm</span> <span class="ow">in</span> <span class="n">algorithms</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">+=</span> <span class="n">algorithm</span><span class="p">(</span><span class="n">seqx</span><span class="p">,</span> <span class="n">seqy</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">matches</span>

    <span class="k">return</span> <span class="n">combined</span></div>



<div class="viewcode-block" id="blunt_overlap">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.blunt_overlap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">blunt_overlap</span><span class="p">(</span>
    <span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">SequenceOverlap</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assembly algorithm to find blunt overlaps. Used for blunt ligation.</span>

<span class="sd">    It basically returns [(len(seqx), 0, 0)] if the right end of seqx is blunt and the</span>
<span class="sd">    left end of seqy is blunt (compatible with blunt ligation). Otherwise, it returns an empty list.</span>

<span class="sd">    Args:</span>
<span class="sd">        seqx (_Dseqrecord): The first sequence</span>
<span class="sd">        seqy (_Dseqrecord): The second sequence</span>
<span class="sd">        limit (int): There for compatibility, but it is ignored</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[SequenceOverlap]: A list of overlaps between the two sequences</span>

<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import blunt_overlap</span>
<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(&quot;AAAAAA&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(&quot;TTTTTT&quot;)</span>
<span class="sd">    &gt;&gt;&gt; blunt_overlap(x, y)</span>
<span class="sd">    [(6, 0, 0)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">three_prime_end</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;blunt&quot;</span>
        <span class="ow">and</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">five_prime_end</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;blunt&quot;</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[]</span></div>



<div class="viewcode-block" id="common_sub_strings">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.common_sub_strings">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">common_sub_strings</span><span class="p">(</span>
    <span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">25</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">SequenceOverlap</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assembly algorithm to find common substrings of length == limit. see the docs of</span>
<span class="sd">    the function common_sub_strings_str for more details. It is case insensitive.</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(&quot;TAAAAAAT&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(&quot;CCaAaAaACC&quot;)</span>
<span class="sd">    &gt;&gt;&gt; common_sub_strings(x, y, limit=5)</span>
<span class="sd">    [(1, 2, 6), (1, 3, 5), (2, 2, 5)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">query_seqx</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">query_seqy</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">seqx</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="n">query_seqx</span> <span class="o">=</span> <span class="n">query_seqx</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">seqy</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="n">query_seqy</span> <span class="o">=</span> <span class="n">query_seqy</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">common_sub_strings_str</span><span class="p">(</span><span class="n">query_seqx</span><span class="p">,</span> <span class="n">query_seqy</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">seqx</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">seqy</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="c1"># Remove matches that start on the second copy of the sequence</span>
    <span class="k">if</span> <span class="n">seqx</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">seqy</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">)]</span>

    <span class="c1"># Trim lengths that span more than the sequence</span>
    <span class="k">if</span> <span class="n">seqx</span><span class="o">.</span><span class="n">circular</span> <span class="ow">or</span> <span class="n">seqy</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="n">max_match_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">))</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">max_match_length</span><span class="p">))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>

    <span class="c1"># Edge case where the sequences are identical</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="p">):</span>
        <span class="n">full_match</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="p">)),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">full_match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">full_match</span><span class="p">]</span>

    <span class="c1"># Remove duplicate matches, see example below</span>
    <span class="c1"># Let&#39;s imagine the following two sequences, where either seqy or both are circular</span>
    <span class="c1"># seqx: 01234</span>
    <span class="c1"># seqy: 123450, circular</span>
    <span class="c1">#</span>
    <span class="c1"># common_sub_strings would return [(0, 5, 5), (1, 0, 4)]</span>
    <span class="c1"># Actually, (1, 0, 4) is a subset of (0, 5, 5), the part</span>
    <span class="c1"># that does not span the origin. To remove matches like this,</span>
    <span class="c1"># We find matches where the origin is spanned in one of the sequences</span>
    <span class="c1"># only, and then remove the subset of that match that does not span the origin.</span>
    <span class="n">shifted_matches</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="n">x_span_origin</span> <span class="o">=</span> <span class="n">seqx</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span>
        <span class="n">y_span_origin</span> <span class="o">=</span> <span class="n">seqy</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_span_origin</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">y_span_origin</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span>
            <span class="n">shifted_matches</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">shift</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">x_span_origin</span> <span class="ow">and</span> <span class="n">y_span_origin</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span>
            <span class="n">shifted_matches</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">shift</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">shifted_matches</span><span class="p">]</span></div>



<div class="viewcode-block" id="gibson_overlap">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.gibson_overlap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gibson_overlap</span><span class="p">(</span><span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">25</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assembly algorithm to find terminal overlaps (e.g. for Gibson assembly).</span>
<span class="sd">    The order matters, we want alignments like:</span>

<span class="sd">    ```</span>
<span class="sd">    seqx:    oooo------xxxx</span>
<span class="sd">    seqy:              xxxx------oooo</span>
<span class="sd">    Product: oooo------xxxx------oooo</span>

<span class="sd">    Not like:</span>

<span class="sd">    seqx:               oooo------xxxx</span>
<span class="sd">    seqy:     xxxx------oooo</span>
<span class="sd">    Product (unwanted): oooo</span>
<span class="sd">    ```</span>

<span class="sd">    Args:</span>
<span class="sd">        seqx (_Dseqrecord): The first sequence</span>
<span class="sd">        seqy (_Dseqrecord): The second sequence</span>
<span class="sd">        limit (int): Minimum length of the overlap</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[SequenceOverlap]: A list of overlaps between the two sequences</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import gibson_overlap</span>
<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(&quot;ttactaAAAAAA&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(&quot;AAAAAAcgcacg&quot;)</span>
<span class="sd">    &gt;&gt;&gt; gibson_overlap(x, y, limit=5)</span>
<span class="sd">    [(6, 0, 6), (7, 0, 5)]</span>
<span class="sd">    &gt;&gt;&gt; gibson_overlap(y, x, limit=5)</span>
<span class="sd">    []</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Because Gibson enzymes remove 5&#39; overhangs, we remove them from the sequence</span>
    <span class="c1"># when looking for homology, then we shift the location of the second fragment accordingly.</span>
    <span class="c1"># This is only relevant for linear fragments, so we don&#39;t need to worry about</span>
    <span class="c1"># shifting locations for circular fragments.</span>
    <span class="n">trim_x_left</span> <span class="o">=</span> <span class="o">-</span><span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span> <span class="k">if</span> <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">trim_x_right</span> <span class="o">=</span> <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">watson_ovhg</span><span class="p">()</span> <span class="k">if</span> <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">watson_ovhg</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">trim_y_left</span> <span class="o">=</span> <span class="o">-</span><span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span> <span class="k">if</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">trim_y_right</span> <span class="o">=</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">watson_ovhg</span><span class="p">()</span> <span class="k">if</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">watson_ovhg</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">stringx</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">trim_x_left</span><span class="p">:</span><span class="n">trim_x_right</span><span class="p">])</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">stringy</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">trim_y_left</span><span class="p">:</span><span class="n">trim_y_right</span><span class="p">])</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="c1"># We have to convert to list because we need to modify the matches</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">common_sub_strings_str</span><span class="p">(</span><span class="n">stringx</span><span class="p">,</span> <span class="n">stringy</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">stringx</span><span class="p">))</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
        <span class="k">match</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">trim_x_left</span>
        <span class="k">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">trim_y_left</span>

    <span class="c1"># convert to tuples again</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">]</span></div>



<div class="viewcode-block" id="sticky_end_sub_strings">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.sticky_end_sub_strings">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sticky_end_sub_strings</span><span class="p">(</span><span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assembly algorithm for ligation of sticky ends.</span>

<span class="sd">    For now, if limit 0 / False (default) only full overlaps are considered.</span>
<span class="sd">    Otherwise, partial overlaps are also returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        seqx (_Dseqrecord): The first sequence</span>
<span class="sd">        seqy (_Dseqrecord): The second sequence</span>
<span class="sd">        limit (int): Minimum length of the overlap</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[SequenceOverlap]: A list of overlaps between the two sequences</span>


<span class="sd">    Ligation of fully overlapping sticky ends, note how the order matters</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseq import Dseq</span>
<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import sticky_end_sub_strings</span>
<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(Dseq.from_full_sequence_and_overhangs(&quot;AAAAAA&quot;, 0, 3))</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(Dseq.from_full_sequence_and_overhangs(&quot;AAAAAA&quot;, 3, 0))</span>
<span class="sd">    &gt;&gt;&gt; sticky_end_sub_strings(x, y, limit=0)</span>
<span class="sd">    [(3, 0, 3)]</span>
<span class="sd">    &gt;&gt;&gt; sticky_end_sub_strings(y, x, limit=0)</span>
<span class="sd">    []</span>

<span class="sd">    Ligation of partially overlapping sticky ends, specified with limit=True</span>

<span class="sd">    &gt;&gt;&gt; x = Dseqrecord(Dseq.from_full_sequence_and_overhangs(&quot;AAAAAA&quot;, 0, 2))</span>
<span class="sd">    &gt;&gt;&gt; y = Dseqrecord(Dseq.from_full_sequence_and_overhangs(&quot;AAAAAA&quot;, 3, 0))</span>
<span class="sd">    &gt;&gt;&gt; sticky_end_sub_strings(x, y, limit=0)</span>
<span class="sd">    []</span>
<span class="sd">    &gt;&gt;&gt; sticky_end_sub_strings(x, y, limit=True)</span>
<span class="sd">    [(4, 0, 2)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">overlap</span> <span class="o">=</span> <span class="n">sum_is_sticky</span><span class="p">(</span>
        <span class="n">seqx</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">three_prime_end</span><span class="p">(),</span> <span class="n">seqy</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">five_prime_end</span><span class="p">(),</span> <span class="n">limit</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[]</span></div>



<div class="viewcode-block" id="zip_match_leftwards">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.zip_match_leftwards">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">zip_match_leftwards</span><span class="p">(</span>
    <span class="n">seqx</span><span class="p">:</span> <span class="n">_SeqRecord</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_SeqRecord</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="n">SequenceOverlap</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SequenceOverlap</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Starting from the rightmost edge of the match, return a new match encompassing the max</span>
<span class="sd">    number of bases. This can be used to return a longer match if a primer aligns for longer</span>
<span class="sd">    than the limit or a shorter match if there are mismatches. This is convenient to maintain</span>
<span class="sd">    as many features as possible. It is used in PCR assembly.</span>

<span class="sd">    &gt;&gt;&gt; seq = _Dseqrecord(&#39;AAAAACGTCCCGT&#39;)</span>
<span class="sd">    &gt;&gt;&gt; primer = _Dseqrecord(&#39;ACGTCCCGT&#39;)</span>
<span class="sd">    &gt;&gt;&gt; match = (13, 9, 0) # an empty match at the end of each</span>
<span class="sd">    &gt;&gt;&gt; zip_match_leftwards(seq, primer, match)</span>
<span class="sd">    (4, 0, 9)</span>

<span class="sd">    Works in circular molecules if the match spans the origin:</span>
<span class="sd">    &gt;&gt;&gt; seq = _Dseqrecord(&#39;TCCCGTAAAAACG&#39;, circular=True)</span>
<span class="sd">    &gt;&gt;&gt; primer = _Dseqrecord(&#39;ACGTCCCGT&#39;)</span>
<span class="sd">    &gt;&gt;&gt; match = (6, 9, 0)</span>
<span class="sd">    &gt;&gt;&gt; zip_match_leftwards(seq, primer, match)</span>
<span class="sd">    (10, 0, 9)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">query_x</span> <span class="o">=</span> <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span>
    <span class="n">query_y</span> <span class="o">=</span> <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">seqy</span><span class="p">)</span>

    <span class="c1"># In circular sequences, the match may go beyond the left-most edge of the sequence if it spans</span>
    <span class="c1"># the origin:</span>
    <span class="c1"># Primer:          ACGTCCCGT</span>
    <span class="c1">#                  |||||||||</span>
    <span class="c1"># Circular seq:    ACGTCCCGT -&gt; Equivalent to Dseqrecord(&#39;CCCGTACGT&#39;, circular=True)</span>
    <span class="c1">#                      ^</span>
    <span class="c1">#                      Origin</span>
    <span class="c1"># We would start from the last T and move leftwards, but we would stop at the origin</span>
    <span class="c1"># For those cases we shift by length, then go back</span>

    <span class="n">end_on_x</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqx</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="ow">and</span> <span class="n">seqx</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="n">end_on_x</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">):</span>
        <span class="n">end_on_x</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span>

    <span class="n">end_on_y</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqy</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="ow">and</span> <span class="n">seqy</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="n">end_on_y</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">):</span>
        <span class="n">end_on_y</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">)</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">query_x</span><span class="p">[:</span><span class="n">end_on_x</span><span class="p">]),</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">query_y</span><span class="p">[:</span><span class="n">end_on_y</span><span class="p">])):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Shift back by length if needed</span>
    <span class="n">start_on_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_on_x</span> <span class="o">-</span> <span class="n">count</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span>
    <span class="n">start_on_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_on_y</span> <span class="o">-</span> <span class="n">count</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqy</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">start_on_x</span><span class="p">,</span> <span class="n">start_on_y</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span></div>



<div class="viewcode-block" id="zip_match_rightwards">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.zip_match_rightwards">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">zip_match_rightwards</span><span class="p">(</span>
    <span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="n">SequenceOverlap</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SequenceOverlap</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as zip_match_leftwards, but towards the right.&quot;&quot;&quot;</span>

    <span class="n">query_x</span> <span class="o">=</span> <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">seqx</span><span class="p">)</span>
    <span class="n">query_y</span> <span class="o">=</span> <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">seqy</span><span class="p">)</span>

    <span class="n">start_on_x</span><span class="p">,</span> <span class="n">start_on_y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">match</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">query_x</span><span class="p">[</span><span class="n">start_on_x</span><span class="p">:],</span> <span class="n">query_y</span><span class="p">[</span><span class="n">start_on_y</span><span class="p">:]):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">start_on_x</span><span class="p">,</span> <span class="n">start_on_y</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span></div>



<div class="viewcode-block" id="seqrecord2_uppercase_DNA_string">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.seqrecord2_uppercase_DNA_string">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">seqr</span><span class="p">:</span> <span class="n">_SeqRecord</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform a Dseqrecord to a sequence string where U is replaced by T, everything is upper case and</span>
<span class="sd">    circular sequences are repeated twice. This is used for PCR, to support primers with U&#39;s (e.g. for USER cloning).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seqr</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqr</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="ow">and</span> <span class="n">seqr</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="primer_template_overlap">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.primer_template_overlap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">primer_template_overlap</span><span class="p">(</span>
    <span class="n">seqx</span><span class="p">:</span> <span class="n">_Dseqrecord</span> <span class="o">|</span> <span class="n">_Primer</span><span class="p">,</span> <span class="n">seqy</span><span class="p">:</span> <span class="n">_Dseqrecord</span> <span class="o">|</span> <span class="n">_Primer</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">mismatches</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">SequenceOverlap</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assembly algorithm to find overlaps between a primer and a template. It accepts mismatches.</span>
<span class="sd">    When there are mismatches, it only returns the common part between the primer and the template.</span>

<span class="sd">    If seqx is a primer and seqy is a template, it represents the binding of a forward primer.</span>
<span class="sd">    If seqx is a template and seqy is a primer, it represents the binding of a reverse primer,</span>
<span class="sd">    where the primer has been passed as its reverse complement (see examples).</span>

<span class="sd">    Args:</span>
<span class="sd">        seqx (_Dseqrecord | _Primer): The primer</span>
<span class="sd">        seqy (_Dseqrecord | _Primer): The template</span>
<span class="sd">        limit (int): Minimum length of the overlap</span>
<span class="sd">        mismatches (int): Maximum number of mismatches (only substitutions, no deletion or insertion)</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[SequenceOverlap]: A list of overlaps between the primer and the template</span>

<span class="sd">    &gt;&gt;&gt; from pydna.dseqrecord import Dseqrecord</span>
<span class="sd">    &gt;&gt;&gt; from pydna.primer import Primer</span>
<span class="sd">    &gt;&gt;&gt; from pydna.assembly2 import primer_template_overlap</span>
<span class="sd">    &gt;&gt;&gt; template = Dseqrecord(&quot;AATTAGCAGCGATCGAGT&quot;, circular=True)</span>
<span class="sd">    &gt;&gt;&gt; primer = Primer(&quot;TTAGCAGC&quot;)</span>
<span class="sd">    &gt;&gt;&gt; primer_template_overlap(primer, template, limit=8, mismatches=0)</span>
<span class="sd">    [(0, 2, 8)]</span>

<span class="sd">    This actually represents the binding of the primer `GCTGCTAA` (reverse complement)</span>
<span class="sd">    &gt;&gt;&gt; primer_template_overlap(template, primer, limit=8, mismatches=0)</span>
<span class="sd">    [(2, 0, 8)]</span>
<span class="sd">    &gt;&gt;&gt; primer_template_overlap(primer, template.reverse_complement(), limit=8, mismatches=0)</span>
<span class="sd">    []</span>
<span class="sd">    &gt;&gt;&gt; primer_template_overlap(primer.reverse_complement(), template, limit=8, mismatches=0)</span>
<span class="sd">    []</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqx</span><span class="p">,</span> <span class="n">_Primer</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqy</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">):</span>
        <span class="n">primer</span> <span class="o">=</span> <span class="n">seqx</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">seqy</span>
        <span class="n">reverse_primer</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqx</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seqy</span><span class="p">,</span> <span class="n">_Primer</span><span class="p">):</span>
        <span class="n">primer</span> <span class="o">=</span> <span class="n">seqy</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">seqx</span>
        <span class="n">reverse_primer</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;One of the sequences must be a primer and the other a Dseqrecord&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">primer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">subject</span> <span class="o">=</span> <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
    <span class="n">query</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">primer</span><span class="p">[:</span><span class="n">limit</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">reverse_primer</span>
        <span class="k">else</span> <span class="n">seqrecord2_uppercase_DNA_string</span><span class="p">(</span><span class="n">primer</span><span class="p">[</span><span class="o">-</span><span class="n">limit</span><span class="p">:])</span>
    <span class="p">)</span>

    <span class="n">re_matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">regex</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span>
            <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">query</span> <span class="o">+</span> <span class="s2">&quot;){s&lt;=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mismatches</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span> <span class="n">overlapped</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">re_matches</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">regex</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span>
            <span class="s2">&quot;(?r)(&quot;</span> <span class="o">+</span> <span class="n">query</span> <span class="o">+</span> <span class="s2">&quot;){s&lt;=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mismatches</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span> <span class="n">overlapped</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">re_match</span> <span class="ow">in</span> <span class="n">re_matches</span><span class="p">:</span>

        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">re_match</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>

        <span class="c1"># For circular sequences the same match is returned twice unless it falls</span>
        <span class="c1"># on the origin, we eliminate duplicates here</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">template</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># This extends match beyond the limit if the primer aligns more than that</span>
        <span class="c1"># and reduces the match if the primer has mismatches</span>
        <span class="k">if</span> <span class="n">reverse_primer</span><span class="p">:</span>
            <span class="c1"># Match in the same format as other assembly algorithms</span>
            <span class="n">starting_match</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">zip_match_rightwards</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">primer</span><span class="p">,</span> <span class="n">starting_match</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Match in the same format as other assembly algorithms</span>
            <span class="n">starting_match</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">primer</span><span class="p">)</span> <span class="o">-</span> <span class="n">limit</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">zip_match_leftwards</span><span class="p">(</span><span class="n">primer</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">starting_match</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">out</span><span class="p">))</span></div>



<div class="viewcode-block" id="fill_left">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.fill_left">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fill_left</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="n">_Dseq</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Dseq</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fill the left overhang of a sequence with the complementary sequence.&quot;&quot;&quot;</span>
    <span class="n">new_watson</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">watson</span>
    <span class="n">new_crick</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">crick</span>

    <span class="c1"># Watson 5&#39; overhang</span>
    <span class="k">if</span> <span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">new_crick</span> <span class="o">=</span> <span class="n">new_crick</span> <span class="o">+</span> <span class="n">reverse_complement</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">watson</span><span class="p">[:</span> <span class="o">-</span><span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span><span class="p">])</span>
    <span class="c1"># Crick 5&#39; overhang</span>
    <span class="k">elif</span> <span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">new_watson</span> <span class="o">=</span> <span class="n">reverse_complement</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">crick</span><span class="p">[</span><span class="o">-</span><span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span> <span class="p">:])</span> <span class="o">+</span> <span class="n">new_watson</span>

    <span class="k">return</span> <span class="n">_Dseq</span><span class="p">(</span><span class="n">new_watson</span><span class="p">,</span> <span class="n">new_crick</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>



<div class="viewcode-block" id="fill_right">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.fill_right">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fill_right</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="n">_Dseq</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Dseq</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fill the right overhang of a sequence with the complementary sequence.&quot;&quot;&quot;</span>
    <span class="n">new_watson</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">watson</span>
    <span class="n">new_crick</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">crick</span>

    <span class="c1"># Watson 3&#39; overhang</span>
    <span class="n">watson_ovhg</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">watson_ovhg</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">watson_ovhg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">new_watson</span> <span class="o">=</span> <span class="n">new_watson</span> <span class="o">+</span> <span class="n">reverse_complement</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">crick</span><span class="p">[:</span><span class="o">-</span><span class="n">watson_ovhg</span><span class="p">])</span>

    <span class="c1"># Crick 3&#39; overhang</span>
    <span class="k">elif</span> <span class="n">watson_ovhg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">new_crick</span> <span class="o">=</span> <span class="n">reverse_complement</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">watson</span><span class="p">[</span><span class="o">-</span><span class="n">watson_ovhg</span><span class="p">:])</span> <span class="o">+</span> <span class="n">new_crick</span>

    <span class="k">return</span> <span class="n">_Dseq</span><span class="p">(</span><span class="n">new_watson</span><span class="p">,</span> <span class="n">new_crick</span><span class="p">,</span> <span class="n">seq</span><span class="o">.</span><span class="n">ovhg</span><span class="p">)</span></div>



<div class="viewcode-block" id="fill_dseq">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.fill_dseq">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fill_dseq</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="n">_Dseq</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Dseq</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fill the overhangs of a sequence with the complementary sequence.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fill_left</span><span class="p">(</span><span class="n">fill_right</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span></div>



<div class="viewcode-block" id="reverse_complement_assembly">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.reverse_complement_assembly">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reverse_complement_assembly</span><span class="p">(</span>
    <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">,</span> <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Complement an assembly, i.e. reverse the order of the fragments and the orientation of the overlaps.&quot;&quot;&quot;</span>
    <span class="n">new_assembly</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">locu</span><span class="p">,</span> <span class="n">locv</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">:</span>
        <span class="n">f_u</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">f_v</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">new_assembly</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="o">-</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span><span class="p">,</span> <span class="n">locv</span><span class="o">.</span><span class="n">_flip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_v</span><span class="p">)),</span> <span class="n">locu</span><span class="o">.</span><span class="n">_flip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_u</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">new_assembly</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="filter_linear_subassemblies">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.filter_linear_subassemblies">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_linear_subassemblies</span><span class="p">(</span>
    <span class="n">linear_assemblies</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">],</span>
    <span class="n">circular_assemblies</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">],</span>
    <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove linear assemblies which are sub-assemblies of circular assemblies&quot;&quot;&quot;</span>
    <span class="n">all_circular_assemblies</span> <span class="o">=</span> <span class="n">circular_assemblies</span> <span class="o">+</span> <span class="p">[</span>
        <span class="n">reverse_complement_assembly</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">fragments</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">circular_assemblies</span>
    <span class="p">]</span>
    <span class="n">filtered_assemblies</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">assem</span>
        <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="n">linear_assemblies</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_sublist</span><span class="p">(</span><span class="n">assem</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">all_circular_assemblies</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="c1"># I don&#39;t think the line below is necessary, but just in case</span>
    <span class="c1"># filtered_assemblies = [l for l in filtered_assemblies if not any(is_sublist(reverse_complement_assembly(l, fragments), c, True) for c in all_circular_assemblies)]</span>
    <span class="k">return</span> <span class="n">filtered_assemblies</span></div>



<div class="viewcode-block" id="remove_subassemblies">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.remove_subassemblies">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">remove_subassemblies</span><span class="p">(</span>
    <span class="n">assemblies</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Filter out subassemblies, i.e. assemblies that are contained within another assembly.</span>

<span class="sd">    For example:</span>
<span class="sd">        [(1, 2, &#39;1[8:14]:2[1:7]&#39;), (2, 3, &#39;2[10:17]:3[1:8]&#39;)]</span>
<span class="sd">        [(1, 2, &#39;1[8:14]:2[1:7]&#39;)]</span>
<span class="sd">    The second one is a subassembly of the first one.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sort by length, longest first</span>
    <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">assemblies</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">filtered_assemblies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">assembly</span> <span class="ow">in</span> <span class="n">assemblies</span><span class="p">:</span>
        <span class="c1"># Check if this assembly is a subassembly of any of the assemblies we have already found</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_sublist</span><span class="p">(</span><span class="n">assembly</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">filtered_assemblies</span><span class="p">):</span>
            <span class="n">filtered_assemblies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filtered_assemblies</span></div>



<div class="viewcode-block" id="assembly2str">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.assembly2str">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assembly2str</span><span class="p">(</span><span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an assembly to a string representation, for example:</span>
<span class="sd">    ((1, 2, [8:14], [1:7]),(2, 3, [10:17], [1:8]))</span>
<span class="sd">    becomes:</span>
<span class="sd">    (&#39;1[8:14]:2[1:7]&#39;, &#39;2[10:17]:3[1:8]&#39;)</span>

<span class="sd">    The reason for this is that by default, a feature &#39;[8:14]&#39; when present in a tuple</span>
<span class="sd">    is printed to the console as `SimpleLocation(ExactPosition(8), ExactPosition(14), strand=1)` (very long).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">u</span><span class="si">}{</span><span class="n">lu</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="si">}{</span><span class="n">lv</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lu</span><span class="p">,</span> <span class="n">lv</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">))</span></div>



<div class="viewcode-block" id="assembly2str_tuple">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.assembly2str_tuple">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assembly2str_tuple</span><span class="p">(</span><span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an assembly to a string representation, like</span>
<span class="sd">    ((1, 2, [8:14], [1:7]),(2, 3, [10:17], [1:8]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">lu</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">lv</span><span class="p">))</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lu</span><span class="p">,</span> <span class="n">lv</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">))</span></div>



<div class="viewcode-block" id="assembly_has_mismatches">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.assembly_has_mismatches">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assembly_has_mismatches</span><span class="p">(</span>
    <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span> <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if an assembly has mismatches. This should never happen and if so it returns an error.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">loc_u</span><span class="p">,</span> <span class="n">loc_v</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">:</span>
        <span class="n">seq_u</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="n">u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">fragments</span><span class="p">[</span><span class="o">-</span><span class="n">u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
        <span class="n">seq_v</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">fragments</span><span class="p">[</span><span class="o">-</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
        <span class="c1"># TODO: Check issue where extraction failed, and whether it would give problems here</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">loc_u</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">seq_u</span><span class="p">)</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="n">loc_v</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">seq_v</span><span class="p">)</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="assembly_is_circular">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.assembly_is_circular">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assembly_is_circular</span><span class="p">(</span>
    <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">,</span> <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Based on the topology of the locations of an assembly, determine if it is circular.</span>
<span class="sd">    This does not work for insertion assemblies, that&#39;s why assemble takes the optional argument is_insertion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">_Dseqrecord</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">circular</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="o">&gt;</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="assemble">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.assemble">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assemble</span><span class="p">(</span>
    <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
    <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">,</span>
    <span class="n">is_insertion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Dseqrecord</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a Dseqrecord from an assembly and a list of fragments.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">is_insertion</span><span class="p">:</span>
        <span class="n">is_circular</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">is_circular</span> <span class="o">=</span> <span class="n">assembly_is_circular</span><span class="p">(</span><span class="n">assembly</span><span class="p">,</span> <span class="n">fragments</span><span class="p">)</span>

    <span class="n">subfragment_representation</span> <span class="o">=</span> <span class="n">edge_representation2subfragment_representation</span><span class="p">(</span>
        <span class="n">assembly</span><span class="p">,</span> <span class="n">is_circular</span>
    <span class="p">)</span>

    <span class="c1"># Sanity check</span>
    <span class="k">for</span> <span class="n">asm_edge</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">:</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">loc_u</span><span class="p">,</span> <span class="n">loc_v</span> <span class="o">=</span> <span class="n">asm_edge</span>
        <span class="n">f_u</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="n">u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">fragments</span><span class="p">[</span><span class="o">-</span><span class="n">u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
        <span class="n">f_v</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">fragments</span><span class="p">[</span><span class="o">-</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
        <span class="n">seq_u</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">loc_u</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">f_u</span><span class="p">)</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">seq_v</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">loc_v</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">f_v</span><span class="p">)</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">seq_u</span> <span class="o">!=</span> <span class="n">seq_v</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mismatch in assembly&quot;</span><span class="p">)</span>

    <span class="c1"># We transform into Dseqrecords (for primers)</span>
    <span class="n">dseqr_fragments</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">f</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">_Dseqrecord</span><span class="p">)</span> <span class="k">else</span> <span class="n">_Dseqrecord</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fragments</span>
    <span class="p">]</span>
    <span class="n">subfragments</span> <span class="o">=</span> <span class="n">get_assembly_subfragments</span><span class="p">(</span>
        <span class="n">dseqr_fragments</span><span class="p">,</span> <span class="n">subfragment_representation</span>
    <span class="p">)</span>

    <span class="c1"># Length of the overlaps between consecutive assembly fragments</span>
    <span class="n">fragment_overlaps</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">]</span>

    <span class="n">out_dseqrecord</span> <span class="o">=</span> <span class="n">_Dseqrecord</span><span class="p">(</span><span class="n">subfragments</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">overlap</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">subfragments</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">fragment_overlaps</span><span class="p">):</span>
        <span class="c1"># Shift the features of the right fragment to the left by `overlap`</span>
        <span class="n">new_features</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">f</span><span class="o">.</span><span class="n">_shift</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out_dseqrecord</span><span class="p">)</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fragment</span><span class="o">.</span><span class="n">features</span>
        <span class="p">]</span>
        <span class="c1"># Join the left sequence including the overlap with the right sequence without the overlap</span>
        <span class="c1"># we use fill_right / fill_left so that it works for ligation of sticky ends</span>
        <span class="n">out_dseqrecord</span> <span class="o">=</span> <span class="n">_Dseqrecord</span><span class="p">(</span>
            <span class="n">fill_right</span><span class="p">(</span><span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="n">fill_left</span><span class="p">(</span><span class="n">fragment</span><span class="o">.</span><span class="n">seq</span><span class="p">)[</span><span class="n">overlap</span><span class="p">:],</span>
            <span class="n">features</span><span class="o">=</span><span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">features</span> <span class="o">+</span> <span class="n">new_features</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># For circular assemblies, close the loop and wrap origin-spanning features</span>
    <span class="k">if</span> <span class="n">is_circular</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">fragment_overlaps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Special case for blunt circularisation</span>
        <span class="k">if</span> <span class="n">overlap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">looped</span><span class="p">()</span>

        <span class="c1"># Remove trailing overlap</span>
        <span class="n">out_dseqrecord</span> <span class="o">=</span> <span class="n">_Dseqrecord</span><span class="p">(</span>
            <span class="n">fill_dseq</span><span class="p">(</span><span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">seq</span><span class="p">)[:</span><span class="o">-</span><span class="n">overlap</span><span class="p">],</span>
            <span class="n">features</span><span class="o">=</span><span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">features</span><span class="p">,</span>
            <span class="n">circular</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">out_dseqrecord</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">feature</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_dseqrecord</span><span class="p">)</span> <span class="ow">or</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_dseqrecord</span><span class="p">):</span>
                <span class="c1"># Wrap around the origin</span>
                <span class="n">feature</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">_shift_location</span><span class="p">(</span>
                    <span class="n">feature</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_dseqrecord</span><span class="p">)</span>
                <span class="p">)</span>

    <span class="k">return</span> <span class="n">out_dseqrecord</span></div>



<div class="viewcode-block" id="annotate_primer_binding_sites">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.annotate_primer_binding_sites">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">annotate_primer_binding_sites</span><span class="p">(</span>
    <span class="n">input_dseqr</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Dseqrecord</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Annotate the primer binding sites in a Dseqrecord.&quot;&quot;&quot;</span>
    <span class="n">fwd</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rvs</span> <span class="o">=</span> <span class="n">fragments</span>
    <span class="n">start_rvs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_dseqr</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rvs</span><span class="p">)</span>

    <span class="n">output_dseqr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">input_dseqr</span><span class="p">)</span>
    <span class="n">output_dseqr</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">y</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">fwd</span><span class="p">),</span>
        <span class="n">type_</span><span class="o">=</span><span class="s2">&quot;primer_bind&quot;</span><span class="p">,</span>
        <span class="n">strand</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="p">[</span><span class="n">fwd</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
        <span class="n">note</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sequence: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fwd</span><span class="o">.</span><span class="n">seq</span><span class="p">)],</span>
    <span class="p">)</span>
    <span class="n">output_dseqr</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">start_rvs</span><span class="p">,</span>
        <span class="n">y</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">output_dseqr</span><span class="p">),</span>
        <span class="n">type_</span><span class="o">=</span><span class="s2">&quot;primer_bind&quot;</span><span class="p">,</span>
        <span class="n">strand</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="p">[</span><span class="n">rvs</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
        <span class="n">note</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sequence: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rvs</span><span class="o">.</span><span class="n">seq</span><span class="p">)],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">output_dseqr</span></div>



<div class="viewcode-block" id="edge_representation2subfragment_representation">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.edge_representation2subfragment_representation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">edge_representation2subfragment_representation</span><span class="p">(</span>
    <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">,</span> <span class="n">is_circular</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SubFragmentRepresentationAssembly</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turn this kind of edge representation fragment 1, fragment 2, right edge on 1, left edge on 2</span>
<span class="sd">    a = [(1, 2, &#39;loc1a&#39;, &#39;loc2a&#39;), (2, 3, &#39;loc2b&#39;, &#39;loc3b&#39;), (3, 1, &#39;loc3c&#39;, &#39;loc1c&#39;)]</span>
<span class="sd">    Into this: fragment 1, left edge on 1, right edge on 1</span>
<span class="sd">    b = [(1, &#39;loc1c&#39;, &#39;loc1a&#39;), (2, &#39;loc2a&#39;, &#39;loc2b&#39;), (3, &#39;loc3b&#39;, &#39;loc3c&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">is_circular</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
            <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">[(</span><span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="p">)</span>
    <span class="n">edge_pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">subfragment_representation</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">_u1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">start_location</span><span class="p">),</span> <span class="p">(</span><span class="n">_u2</span><span class="p">,</span> <span class="n">_v2</span><span class="p">,</span> <span class="n">end_location</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edge_pairs</span><span class="p">:</span>
        <span class="n">subfragment_representation</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v1</span><span class="p">,</span> <span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">subfragment_representation</span><span class="p">)</span></div>



<div class="viewcode-block" id="subfragment_representation2edge_representation">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.subfragment_representation2edge_representation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">subfragment_representation2edge_representation</span><span class="p">(</span>
    <span class="n">assembly</span><span class="p">:</span> <span class="n">SubFragmentRepresentationAssembly</span><span class="p">,</span> <span class="n">is_circular</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turn this kind of subfragment representation fragment 1, left edge on 1, right edge on 1</span>
<span class="sd">    a = [(1, &#39;loc1c&#39;, &#39;loc1a&#39;), (2, &#39;loc2a&#39;, &#39;loc2b&#39;), (3, &#39;loc3b&#39;, &#39;loc3c&#39;)]</span>
<span class="sd">    Into this: fragment 1, fragment 2, right edge on 1, left edge on 2</span>
<span class="sd">    b = [(1, 2, &#39;loc1a&#39;, &#39;loc2a&#39;), (2, 3, &#39;loc2b&#39; &#39;loc3b&#39;), (3, 1, &#39;loc3c&#39;, &#39;loc1c&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">edge_representation</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate through the assembly pairwise to create the edge representation</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">frag1</span><span class="p">,</span> <span class="n">left1</span><span class="p">,</span> <span class="n">right1</span> <span class="o">=</span> <span class="n">assembly</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">frag2</span><span class="p">,</span> <span class="n">left2</span><span class="p">,</span> <span class="n">right2</span> <span class="o">=</span> <span class="n">assembly</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Create the edge between the current and next fragment</span>
        <span class="n">edge_representation</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">frag1</span><span class="p">,</span> <span class="n">frag2</span><span class="p">,</span> <span class="n">right1</span><span class="p">,</span> <span class="n">left2</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">is_circular</span><span class="p">:</span>
        <span class="c1"># Add the edge from the last fragment back to the first</span>
        <span class="n">frag_last</span><span class="p">,</span> <span class="n">left_last</span><span class="p">,</span> <span class="n">right_last</span> <span class="o">=</span> <span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">frag_first</span><span class="p">,</span> <span class="n">left_first</span><span class="p">,</span> <span class="n">right_first</span> <span class="o">=</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">edge_representation</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">frag_last</span><span class="p">,</span> <span class="n">frag_first</span><span class="p">,</span> <span class="n">right_last</span><span class="p">,</span> <span class="n">left_first</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edge_representation</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_assembly_subfragments">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.get_assembly_subfragments">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_assembly_subfragments</span><span class="p">(</span>
    <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
    <span class="n">subfragment_representation</span><span class="p">:</span> <span class="n">SubFragmentRepresentationAssembly</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From the fragment representation returned by edge_representation2subfragment_representation, get the subfragments that are joined together.</span>

<span class="sd">    Subfragments are the slices of the fragments that are joined together</span>

<span class="sd">    For example:</span>
<span class="sd">    ```</span>
<span class="sd">      --A--</span>
<span class="sd">    TACGTAAT</span>
<span class="sd">      --B--</span>
<span class="sd">     TCGTAACGA</span>

<span class="sd">    Gives: TACGTAA / CGTAACGA</span>
<span class="sd">    ```</span>
<span class="sd">    To reproduce:</span>
<span class="sd">    ```</span>
<span class="sd">    a = Dseqrecord(&#39;TACGTAAT&#39;)</span>
<span class="sd">    b = Dseqrecord(&#39;TCGTAACGA&#39;)</span>
<span class="sd">    f = Assembly([a, b], limit=5)</span>
<span class="sd">    a0 = f.get_linear_assemblies()[0]</span>
<span class="sd">    print(assembly2str(a0))</span>
<span class="sd">    a0_subfragment_rep =edge_representation2subfragment_representation(a0, False)</span>
<span class="sd">    for f in get_assembly_subfragments([a, b], a0_subfragment_rep):</span>
<span class="sd">        print(f.seq)</span>

<span class="sd">    # prints TACGTAA and CGTAACGA</span>
<span class="sd">    ```</span>

<span class="sd">    Subfragments: `cccccgtatcgtgt`, `atcgtgtactgtcatattc`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subfragments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span> <span class="ow">in</span> <span class="n">subfragment_representation</span><span class="p">:</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">fragments</span><span class="p">[</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">else</span> <span class="n">fragments</span><span class="p">[</span><span class="o">-</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">subfragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extract_subfragment</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">subfragments</span></div>



<div class="viewcode-block" id="extract_subfragment">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.extract_subfragment">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">extract_subfragment</span><span class="p">(</span>
    <span class="n">seq</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span> <span class="n">start_location</span><span class="p">:</span> <span class="n">Location</span><span class="p">,</span> <span class="n">end_location</span><span class="p">:</span> <span class="n">Location</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Dseqrecord</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract a subfragment from a sequence for an assembly, given the start and end locations of the subfragment.&quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">start_location</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">start_location</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">end_location</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">end_location</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Special case, some of it could be handled by better Dseqrecord slicing in the future</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">circular</span>
        <span class="ow">and</span> <span class="n">start_location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">end_location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">_locations_overlap</span><span class="p">(</span><span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
    <span class="p">):</span>
        <span class="c1"># The overhang is different for origin-spanning features, for instance</span>
        <span class="c1"># for a feature join{[12:13], [0:3]} in a sequence of length 13, the overhang</span>
        <span class="c1"># is -4, not 9</span>
        <span class="n">ovhg</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">end</span> <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="k">else</span> <span class="n">start</span> <span class="o">-</span> <span class="n">end</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="c1"># edge case</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ovhg</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
            <span class="n">ovhg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dummy_cut</span> <span class="o">=</span> <span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">ovhg</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">open_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">apply_cut</span><span class="p">(</span><span class="n">dummy_cut</span><span class="p">,</span> <span class="n">dummy_cut</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_Dseqrecord</span><span class="p">(</span><span class="n">fill_dseq</span><span class="p">(</span><span class="n">open_seq</span><span class="o">.</span><span class="n">seq</span><span class="p">),</span> <span class="n">features</span><span class="o">=</span><span class="n">open_seq</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">seq</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span></div>



<div class="viewcode-block" id="is_sublist">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.is_sublist">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_sublist</span><span class="p">(</span><span class="n">sublist</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">my_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">my_list_is_cyclic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns True if argument sublist is a sublist of argument my_list (can be treated as cyclic), False otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; is_sublist([1, 2], [1, 2, 3], False)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_sublist([1, 2], [1, 3, 2], False)</span>
<span class="sd">    False</span>

<span class="sd">    # See the case here for cyclic lists</span>
<span class="sd">    &gt;&gt;&gt; is_sublist([3, 1], [1, 2, 3], False)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_sublist([3, 1], [1, 2, 3], True)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">my_list_is_cyclic</span><span class="p">:</span>
        <span class="n">my_list</span> <span class="o">=</span> <span class="n">my_list</span> <span class="o">+</span> <span class="n">my_list</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_list</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Just in case tuples were passed</span>
        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">my_list</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">sublist</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="circular_permutation_min_abs">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.circular_permutation_min_abs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">circular_permutation_min_abs</span><span class="p">(</span><span class="n">lst</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the circular permutation of lst with the smallest absolute value first.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; circular_permutation_min_abs([1, 2, 3])</span>
<span class="sd">    [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; circular_permutation_min_abs([3, 1, 2])</span>
<span class="sd">    [1, 2, 3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_abs_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">lst</span><span class="p">[</span><span class="n">min_abs_index</span><span class="p">:]</span> <span class="o">+</span> <span class="n">lst</span><span class="p">[:</span><span class="n">min_abs_index</span><span class="p">]</span></div>



<div class="viewcode-block" id="Assembly">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Assembly</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assembly of a list of DNA fragments into linear or circular constructs.</span>
<span class="sd">    Accepts a list of Dseqrecords (source fragments) to</span>
<span class="sd">    initiate an Assembly object. Several methods are available for analysis</span>
<span class="sd">    of overlapping sequences, graph construction and assembly.</span>

<span class="sd">    The assembly contains a directed graph, where nodes represent fragments and</span>
<span class="sd">    edges represent overlaps between fragments. :</span>
<span class="sd">    - The node keys are integers, representing the index of the fragment in the</span>
<span class="sd">    input list of fragments. The sign of the node key represents the orientation</span>
<span class="sd">    of the fragment, positive for forward orientation, negative for reverse orientation.</span>
<span class="sd">    - The edges contain the locations of the overlaps in the fragments. For an edge (u, v, key):</span>
<span class="sd">        - u and v are the nodes connected by the edge.</span>
<span class="sd">        - key is a string that represents the location of the overlap. In the format:</span>
<span class="sd">        &#39;u[start:end](strand):v[start:end](strand)&#39;.</span>
<span class="sd">        - Edges have a &#39;locations&#39; attribute, which is a list of two FeatureLocation objects,</span>
<span class="sd">        representing the location of the overlap in the u and v fragment, respectively.</span>
<span class="sd">        - You can think of an edge as a representation of the join of two fragments.</span>

<span class="sd">    If fragment 1 and 2 share a subsequence of 6bp, [8:14] in fragment 1 and [1:7] in fragment 2,</span>
<span class="sd">    there will be 4 edges representing that overlap in the graph, for all possible</span>
<span class="sd">    orientations of the fragments (see add_edges_from_match for details):</span>
<span class="sd">    - `(1, 2, &#39;1[8:14]:2[1:7]&#39;)`</span>
<span class="sd">    - `(2, 1, &#39;2[1:7]:1[8:14]&#39;)`</span>
<span class="sd">    - `(-1, -2, &#39;-1[0:6]:-2[10:16]&#39;)`</span>
<span class="sd">    - `(-2, -1, &#39;-2[10:16]:-1[0:6]&#39;)`</span>

<span class="sd">    An assembly can be thought of as a tuple of graph edges, but instead of representing them with node indexes and keys, we represent them</span>
<span class="sd">    as u, v, locu, locv, where u and v are the nodes connected by the edge, and locu and locv are the locations of the overlap in the first</span>
<span class="sd">    and second fragment. Assemblies are then represented as:</span>
<span class="sd">    - Linear: ((1, 2, [8:14], [1:7]), (2, 3, [10:17], [1:8]))</span>
<span class="sd">    - Circular: ((1, 2, [8:14], [1:7]), (2, 3, [10:17], [1:8]), (3, 1, [12:17], [1:6]))</span>
<span class="sd">    Note that the first and last fragment are the same in a circular assembly.</span>

<span class="sd">    The following constrains are applied to remove duplicate assemblies:</span>
<span class="sd">    - Circular assemblies: the first subfragment is not reversed, and has the smallest index in the input fragment list.</span>
<span class="sd">      use_fragment_order is ignored.</span>
<span class="sd">    - Linear assemblies:</span>
<span class="sd">        - Using uid (see add_edges_from_match) to identify unique edges.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frags : list</span>
<span class="sd">        A list of Dseqrecord objects.</span>
<span class="sd">    limit : int, optional</span>
<span class="sd">        The shortest shared homology to be considered, this is passed as the third argument to the `algorithm` function.</span>
<span class="sd">        For certain algorithms, this might be ignored.</span>
<span class="sd">    algorithm : function, optional</span>
<span class="sd">        The algorithm used to determine the shared sequences. It&#39;s a function that takes two Dseqrecord objects as inputs,</span>
<span class="sd">        and will get passed the third argument (limit), that may or may not be used. It must return a list of overlaps</span>
<span class="sd">        (see common_sub_strings for an example).</span>
<span class="sd">    use_fragment_order : bool, optional</span>
<span class="sd">        It&#39;s set to True by default to reproduce legacy pydna behaviour: only assemblies that start with the first fragment and end with the last are considered.</span>
<span class="sd">        You should set it to False.</span>
<span class="sd">    use_all_fragments : bool, optional</span>
<span class="sd">        Constrain the assembly to use all fragments.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    from assembly2 import Assembly, assembly2str</span>
<span class="sd">    from pydna.dseqrecord import Dseqrecord</span>

<span class="sd">    example_fragments = (</span>
<span class="sd">        Dseqrecord(&#39;AacgatCAtgctcc&#39;, name=&#39;a&#39;),</span>
<span class="sd">        Dseqrecord(&#39;TtgctccTAAattctgc&#39;, name=&#39;b&#39;),</span>
<span class="sd">        Dseqrecord(&#39;CattctgcGAGGacgatG&#39;, name=&#39;c&#39;),</span>
<span class="sd">    )</span>

<span class="sd">    asm = Assembly(example_fragments, limit=5, use_fragment_order=False)</span>
<span class="sd">    print(&#39;Linear ===============&#39;)</span>
<span class="sd">    for assembly in asm.get_linear_assemblies():</span>
<span class="sd">        print(&#39; &#39;, assembly2str(assembly))</span>
<span class="sd">    print(&#39;Circular =============&#39;)</span>
<span class="sd">    for assembly in asm.get_circular_assemblies():</span>
<span class="sd">        print(&#39; &#39;, assembly2str(assembly))</span>

<span class="sd">    # Prints</span>
<span class="sd">    Linear ===============</span>
<span class="sd">        (&#39;1[8:14]:2[1:7]&#39;, &#39;2[10:17]:3[1:8]&#39;)</span>
<span class="sd">        (&#39;2[10:17]:3[1:8]&#39;, &#39;3[12:17]:1[1:6]&#39;)</span>
<span class="sd">        (&#39;3[12:17]:1[1:6]&#39;, &#39;1[8:14]:2[1:7]&#39;)</span>
<span class="sd">        (&#39;1[1:6]:3[12:17]&#39;,)</span>
<span class="sd">        (&#39;2[1:7]:1[8:14]&#39;,)</span>
<span class="sd">        (&#39;3[1:8]:2[10:17]&#39;,)</span>
<span class="sd">    Circular =============</span>
<span class="sd">        (&#39;1[8:14]:2[1:7]&#39;, &#39;2[10:17]:3[1:8]&#39;, &#39;3[12:17]:1[1:6]&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
        <span class="n">algorithm</span><span class="p">:</span> <span class="n">AssemblyAlgorithmType</span> <span class="o">=</span> <span class="n">common_sub_strings</span><span class="p">,</span>
        <span class="n">use_fragment_order</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">use_all_fragments</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># TODO: allow for the same fragment to be included more than once?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
        <span class="c1"># Add positive and negative nodes for forward and reverse fragments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;seq&quot;</span><span class="p">:</span> <span class="n">f</span><span class="p">})</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frags</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span>
            <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;seq&quot;</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()})</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Iterate over all possible combinations of fragments</span>
        <span class="n">fragment_pairs</span> <span class="o">=</span> <span class="n">_itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">fragment_pairs</span><span class="p">:</span>
            <span class="c1"># All the relative orientations of the fragments in the pair</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span><span class="p">]):</span>
                <span class="n">u_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s2">&quot;seq&quot;</span><span class="p">]</span>
                <span class="n">v_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s2">&quot;seq&quot;</span><span class="p">]</span>
                <span class="n">matches</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">(</span><span class="n">u_seq</span><span class="p">,</span> <span class="n">v_seq</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from_match</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u_seq</span><span class="p">,</span> <span class="n">v_seq</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">frags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="n">algorithm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_fragment_order</span> <span class="o">=</span> <span class="n">use_fragment_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span> <span class="o">=</span> <span class="n">use_all_fragments</span>

        <span class="k">return</span>

<div class="viewcode-block" id="Assembly.assembly_is_valid">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.assembly_is_valid">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">assembly_is_valid</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">fragments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span> <span class="o">|</span> <span class="n">_Primer</span><span class="p">],</span>
        <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">,</span>
        <span class="n">is_circular</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">use_all_fragments</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">is_insertion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the assembly is valid, False otherwise. See function comments for conditions tested.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_circular</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Linear assemblies may get begin-1-end, begin-2-end, these are removed here.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">use_all_fragments</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragments</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Here we check whether subsequent pairs of fragments are compatible, for instance:</span>
        <span class="c1"># Compatible (overlap of 1 and 2 occurs before overlap of 2 and 3):</span>
        <span class="c1"># (1,2,[2:9],[0:7]), (2,3,[12:19],[0:7])</span>
        <span class="c1">#    -- A --</span>
        <span class="c1"># 1 gtatcgtgt     -- B --</span>
        <span class="c1"># 2   atcgtgtactgtcatattc</span>
        <span class="c1"># 3               catattcaa</span>
        <span class="c1"># Incompatible (overlap of 1 and 2 occurs after overlap of 2 and 3):</span>
        <span class="c1"># (1,2,[2:9],[13:20]), (2,3,[0:7],[0:7])</span>
        <span class="c1">#                 -- A --</span>
        <span class="c1">#  1 -- B --    gtatcgtgt</span>
        <span class="c1">#  2 catattcccccccatcgtgtactgt</span>
        <span class="c1">#  3 catattcaa</span>
        <span class="c1"># Redundant: overlap of 1 and 2 ends at the same spot as overlap of 2 and 3</span>
        <span class="c1"># (1,2,[2:9],[1:8]), (2,3,[0:8],[0:8])</span>
        <span class="c1">#    -- A --</span>
        <span class="c1">#  gtatcgtgt</span>
        <span class="c1">#   catcgtgtactgtcatattc</span>
        <span class="c1">#   catcgtgtactgtcatattc</span>
        <span class="c1">#   -- B ---</span>
        <span class="k">if</span> <span class="n">is_circular</span><span class="p">:</span>
            <span class="c1"># In a circular assembly, first and last fragment must be the same</span>
            <span class="k">if</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">assembly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">edge_pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">assembly</span><span class="p">,</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">assembly</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">assembly</span><span class="p">,</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">_u1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">start_location</span><span class="p">),</span> <span class="p">(</span><span class="n">_u2</span><span class="p">,</span> <span class="n">_v2</span><span class="p">,</span> <span class="n">end_location</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edge_pairs</span><span class="p">:</span>
            <span class="c1"># Incompatible as described in figure above</span>
            <span class="n">fragment</span> <span class="o">=</span> <span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">_Primer</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">fragment</span><span class="o">.</span><span class="n">circular</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">start_location</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">_location_boundaries</span><span class="p">(</span>
                <span class="n">end_location</span>
            <span class="p">)[</span>
                <span class="mi">1</span>
            <span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Fragments are used only once</span>
        <span class="n">nodes_used</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">edge_representation2subfragment_representation</span><span class="p">(</span>
                <span class="n">assembly</span><span class="p">,</span> <span class="n">is_circular</span> <span class="ow">or</span> <span class="n">is_insertion</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_used</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">nodes_used</span><span class="p">))):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Assembly.add_edges_from_match">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.add_edges_from_match">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_edges_from_match</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">SequenceOverlap</span><span class="p">,</span>
        <span class="n">u</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">v</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">first</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span>
        <span class="n">secnd</span><span class="p">:</span> <span class="n">_Dseqrecord</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add edges to the graph from a match returned by the `algorithm` function (see pydna.common_substrings). For</span>
<span class="sd">        format of edges (see documentation of the Assembly class).</span>

<span class="sd">        Matches are directional, because not all `algorithm` functions return the same match for (u,v) and (v,u). For example,</span>
<span class="sd">        homologous recombination does but sticky end ligation does not. The function returns two edges:</span>
<span class="sd">        - Fragments in the orientation they were passed, with locations of the match (u, v, loc_u, loc_v)</span>
<span class="sd">        - Reverse complement of the fragments with inverted order, with flipped locations (-v, -u, flip(loc_v), flip(loc_u))/</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_start</span><span class="p">,</span> <span class="n">y_start</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">match</span>
        <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Edge case, blunt ligation</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="p">[</span><span class="n">SimpleLocation</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="n">x_start</span><span class="p">),</span> <span class="n">SimpleLocation</span><span class="p">(</span><span class="n">y_start</span><span class="p">,</span> <span class="n">y_start</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We use shift_location with 0 to wrap origin-spanning features</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">_shift_location</span><span class="p">(</span>
                    <span class="n">SimpleLocation</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="n">x_start</span> <span class="o">+</span> <span class="n">length</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">_shift_location</span><span class="p">(</span>
                    <span class="n">SimpleLocation</span><span class="p">(</span><span class="n">y_start</span><span class="p">,</span> <span class="n">y_start</span> <span class="o">+</span> <span class="n">length</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">secnd</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">]</span>

        <span class="c1"># Flip the locations to get the reverse complement</span>
        <span class="n">rc_locs</span> <span class="o">=</span> <span class="p">[</span><span class="n">locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_flip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">first</span><span class="p">)),</span> <span class="n">locs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_flip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">secnd</span><span class="p">))]</span>

        <span class="c1"># Unique id that identifies the edge in either orientation</span>
        <span class="n">uid</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">u</span><span class="si">}{</span><span class="n">locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="si">}{</span><span class="n">locs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">combinations</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">locs</span><span class="p">),</span>
            <span class="p">(</span><span class="o">-</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span><span class="p">,</span> <span class="n">rc_locs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">u</span><span class="si">}{</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="si">}{</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">locations</span><span class="o">=</span><span class="n">l</span><span class="p">,</span> <span class="n">uid</span><span class="o">=</span><span class="n">uid</span><span class="p">)</span></div>


<div class="viewcode-block" id="Assembly.format_assembly_edge">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.format_assembly_edge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_assembly_edge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">graph_edge</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AssemblyEdgeType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Go from the (u, v, key) to the (u, v, locu, locv) format.&quot;&quot;&quot;</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">graph_edge</span>
        <span class="n">locu</span><span class="p">,</span> <span class="n">locv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">key</span><span class="p">)[</span><span class="s2">&quot;locations&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">locu</span><span class="p">,</span> <span class="n">locv</span></div>


<div class="viewcode-block" id="Assembly.get_linear_assemblies">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.get_linear_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_assemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get linear assemblies, applying the constrains described in __init__, ensuring that paths represent</span>
<span class="sd">        real assemblies (see assembly_is_valid). Subassemblies are removed (see remove_subassemblies).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Copy the graph since we will add the begin and end mock nodes</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="s2">&quot;begin&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_fragment_order</span><span class="p">:</span>
            <span class="c1"># Path must start with the first fragment and end with the last</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;begin&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;begin&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">),</span> <span class="s2">&quot;end&quot;</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">),</span> <span class="s2">&quot;end&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;begin&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">)</span>

        <span class="n">unique_linear_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_linear_paths</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">possible_assemblies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_possible_assembly_number</span><span class="p">(</span><span class="n">unique_linear_paths</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">possible_assemblies</span> <span class="o">&gt;</span> <span class="n">max_assemblies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Too many assemblies (</span><span class="si">{</span><span class="n">possible_assemblies</span><span class="si">}</span><span class="s2"> pre-validation) to assemble&quot;</span>
            <span class="p">)</span>

        <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_path2assembly_list</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">unique_linear_paths</span><span class="p">),</span>
            <span class="p">[],</span>
        <span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">only_adjacent_edges</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">out</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_uses_only_adjacent_edges</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">remove_subassemblies</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="Assembly.node_path2assembly_list">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.node_path2assembly_list">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">node_path2assembly_list</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cycle</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">circular</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a node path in the format [1, 2, 3] (as returned by _nx.cycles.simple_cycles) to a list of all</span>
<span class="sd">          possible assemblies.</span>

<span class="sd">        There may be multiple assemblies for a given node path, if there are several edges connecting two nodes,</span>
<span class="sd">        for example two overlaps between 1 and 2, and single overlap between 2 and 3 should return 3 assemblies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">combine</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">pairing</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">cycle</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">cycle</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">circular</span> <span class="k">else</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">cycle</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pairing</span><span class="p">:</span>
            <span class="n">combine</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]])</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format_assembly_edge</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">combine</span><span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Assembly.get_unique_linear_paths">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.get_unique_linear_paths">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_unique_linear_paths</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">G_with_begin_end</span><span class="p">:</span> <span class="n">_nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">,</span> <span class="n">max_paths</span><span class="o">=</span><span class="mi">10000</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get unique linear paths from the graph, removing those that contain the same node twice.&quot;&quot;&quot;</span>
        <span class="c1"># We remove the begin and end nodes, and get all paths without edges</span>
        <span class="c1"># e.g. we will get [1, 2, 3] only once, even if multiple edges connect</span>
        <span class="c1"># 1 and 2 or 2 and 3, by converting to DiGraph.</span>

        <span class="c1"># Cutoff has a different meaning of what one would expect, see https://github.com/networkx/networkx/issues/2762</span>
        <span class="n">node_paths</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">limit_iterator</span><span class="p">(</span>
                <span class="n">_nx</span><span class="o">.</span><span class="n">all_simple_paths</span><span class="p">(</span>
                    <span class="n">_nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">G_with_begin_end</span><span class="p">),</span>
                    <span class="s2">&quot;begin&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;end&quot;</span><span class="p">,</span>
                    <span class="n">cutoff</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="n">max_paths</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Remove those that contain the same node twice</span>
        <span class="n">node_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_paths</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">x</span><span class="p">)))]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">:</span>
            <span class="n">node_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_paths</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)]</span>

        <span class="c1"># For each path, we check if there are reverse complement duplicates</span>
        <span class="c1"># See: https://github.com/manulera/OpenCloning_backend/issues/160</span>
        <span class="n">unique_node_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node_paths</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_node_paths</span><span class="p">:</span>
                <span class="n">unique_node_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unique_node_paths</span></div>


<div class="viewcode-block" id="Assembly.get_possible_assembly_number">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.get_possible_assembly_number">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_possible_assembly_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of possible assemblies from a list of node paths. Basically, for each path</span>
<span class="sd">        passed as a list of integers / nodes, we calculate the number of paths possible connecting</span>
<span class="sd">        the nodes in that order, given the graph (all the edges connecting them).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">possibilities</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="n">this_path</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                    <span class="n">this_path</span> <span class="o">*=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span>
            <span class="n">possibilities</span> <span class="o">+=</span> <span class="n">this_path</span>
        <span class="k">return</span> <span class="n">possibilities</span></div>


<div class="viewcode-block" id="Assembly.get_circular_assemblies">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.get_circular_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_circular_assemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get circular assemblies, applying the constrains described in __init__, ensuring that paths represent</span>
<span class="sd">        real assemblies (see assembly_is_valid).&quot;&quot;&quot;</span>
        <span class="c1"># The constrain of circular sequence is that the first node is the fragment with the smallest index in its initial orientation,</span>
        <span class="c1"># this is ensured by the circular_permutation_min_abs function + the filter below</span>
        <span class="n">sorted_cycles</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span>
            <span class="n">circular_permutation_min_abs</span><span class="p">,</span>
            <span class="n">limit_iterator</span><span class="p">(</span>
                <span class="n">_nx</span><span class="o">.</span><span class="n">cycles</span><span class="o">.</span><span class="n">simple_cycles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">length_bound</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)),</span>
                <span class="mi">10000</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="n">sorted_cycles</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sorted_cycles</span><span class="p">)</span>
        <span class="c1"># cycles.simple_cycles returns lists [1,2,3] not assemblies, see self.cycle2circular_assemblies</span>

        <span class="c1"># We apply constrains already here because sometimes the combinatorial explosion is too large</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">:</span>
            <span class="n">sorted_cycles</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sorted_cycles</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)]</span>

        <span class="c1"># Remove cycles with duplicates</span>
        <span class="n">sorted_cycles</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sorted_cycles</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">c</span><span class="p">)))]</span>
        <span class="n">possible_assembly_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_possible_assembly_number</span><span class="p">(</span>
            <span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sorted_cycles</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">possible_assembly_number</span> <span class="o">&gt;</span> <span class="n">max_assemblies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Too many assemblies (</span><span class="si">{</span><span class="n">possible_assembly_number</span><span class="si">}</span><span class="s2"> pre-validation) to assemble&quot;</span>
            <span class="p">)</span>

        <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_path2assembly_list</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">sorted_cycles</span><span class="p">),</span> <span class="p">[]</span>
        <span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">only_adjacent_edges</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">out</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_uses_only_adjacent_edges</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="Assembly.format_insertion_assembly">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.format_insertion_assembly">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_insertion_assembly</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EdgeRepresentationAssembly</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sorts the fragment representing a cycle so that they represent an insertion assembly if possible,</span>
<span class="sd">        else returns None.</span>

<span class="sd">        Here we check if one of the joins between fragments represents the edges of an insertion assembly</span>
<span class="sd">        The fragment must be linear, and the join must be as indicated below</span>

<span class="sd">        ```</span>
<span class="sd">        --------         -------           Fragment 1</span>
<span class="sd">            ||            ||</span>
<span class="sd">            xxxxxxxx      ||               Fragment 2</span>
<span class="sd">                  ||      ||</span>
<span class="sd">                  oooooooooo               Fragment 3</span>
<span class="sd">        ```</span>
<span class="sd">        The above example will be [(1, 2, [4:6], [0:2]), (2, 3, [6:8], [0:2]), (3, 1, [8:10], [9:11)])]</span>

<span class="sd">        These could be returned in any order by simple_cycles, so we sort the edges so that the first</span>
<span class="sd">        and last `u` and `v` match the fragment that gets the insertion (1 in the example above).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_pair_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Pair edges with one another</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">((</span><span class="n">_u1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">end_location</span><span class="p">),</span> <span class="p">(</span><span class="n">_u2</span><span class="p">,</span> <span class="n">_v2</span><span class="p">,</span> <span class="n">start_location</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">assembly</span><span class="p">,</span> <span class="n">assembly</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">assembly</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="n">fragment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Find the pair of edges that should be last and first  ((3, 1, [8:10], [9:11)]), (1, 2, [4:6], [0:2]) in</span>
            <span class="c1"># the example above. Only one of the pairs of edges should satisfy this condition for the topology to make sense.</span>
            <span class="n">left_of_insertion</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">start_location</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">right_of_insertion</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">end_location</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fragment</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">right_of_insertion</span> <span class="o">&gt;=</span> <span class="n">left_of_insertion</span>
                <span class="c1"># The below condition is for single-site integration.</span>
                <span class="c1"># The reason to use locations_overlap instead of equality is because the location might extend</span>
                <span class="c1"># left of right. For example, let&#39;s take ACCGGTTT as homology arm for an integration:</span>
                <span class="c1">#</span>
                <span class="c1"># insert aaACCGGTTTccACCGGTTTtt</span>
                <span class="c1"># genome aaACCGGTTTtt</span>
                <span class="c1">#</span>
                <span class="c1"># The locations of homology on the genome are [0:10] and [2:12], so not identical</span>
                <span class="c1"># but they overlap.</span>
                <span class="ow">or</span> <span class="n">_locations_overlap</span><span class="p">(</span><span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="n">edge_pair_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_pair_index</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">shift_by</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge_pair_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">assembly</span><span class="p">[</span><span class="n">shift_by</span><span class="p">:]</span> <span class="o">+</span> <span class="n">assembly</span><span class="p">[:</span><span class="n">shift_by</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assembly.format_insertion_assembly_edge_case">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.format_insertion_assembly_edge_case">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_insertion_assembly_edge_case</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">assembly</span><span class="p">:</span> <span class="n">EdgeRepresentationAssembly</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EdgeRepresentationAssembly</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Edge case from https://github.com/manulera/OpenCloning_backend/issues/329</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">same_assembly</span> <span class="o">=</span> <span class="n">assembly</span><span class="p">[:]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assembly</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">same_assembly</span>
        <span class="p">((</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">loc_f1_1</span><span class="p">,</span> <span class="n">loc_f2_1</span><span class="p">),</span> <span class="p">(</span><span class="n">_f2</span><span class="p">,</span> <span class="n">_f1</span><span class="p">,</span> <span class="n">loc_f2_2</span><span class="p">,</span> <span class="n">loc_f1_2</span><span class="p">))</span> <span class="o">=</span> <span class="n">assembly</span>

        <span class="k">if</span> <span class="n">f1</span> <span class="o">!=</span> <span class="n">_f1</span> <span class="ow">or</span> <span class="n">_f2</span> <span class="o">!=</span> <span class="n">f2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">same_assembly</span>

        <span class="k">if</span> <span class="n">loc_f2_1</span> <span class="o">==</span> <span class="n">loc_f2_2</span> <span class="ow">or</span> <span class="n">loc_f1_2</span> <span class="o">==</span> <span class="n">loc_f1_1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">same_assembly</span>

        <span class="n">fragment1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">fragment2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_locations_overlap</span><span class="p">(</span>
            <span class="n">loc_f1_1</span><span class="p">,</span> <span class="n">loc_f1_2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment1</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_locations_overlap</span><span class="p">(</span><span class="n">loc_f2_2</span><span class="p">,</span> <span class="n">loc_f2_1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment2</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">same_assembly</span>

        <span class="c1"># Sort to make compatible with insertion assembly</span>
        <span class="k">if</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">loc_f1_1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">loc_f1_2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">new_assembly</span> <span class="o">=</span> <span class="n">same_assembly</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_assembly</span> <span class="o">=</span> <span class="n">same_assembly</span><span class="p">[:]</span>

        <span class="p">((</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">loc_f1_1</span><span class="p">,</span> <span class="n">loc_f2_1</span><span class="p">),</span> <span class="p">(</span><span class="n">_f2</span><span class="p">,</span> <span class="n">_f1</span><span class="p">,</span> <span class="n">loc_f2_2</span><span class="p">,</span> <span class="n">loc_f1_2</span><span class="p">))</span> <span class="o">=</span> <span class="n">new_assembly</span>

        <span class="n">fragment1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fragment1</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">same_assembly</span>
        <span class="n">fragment2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Extract boundaries</span>
        <span class="n">f2_1_start</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">loc_f2_1</span><span class="p">)</span>
        <span class="n">f2_2_start</span><span class="p">,</span> <span class="n">f2_2_end</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">loc_f2_2</span><span class="p">)</span>
        <span class="n">f1_1_start</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">loc_f1_1</span><span class="p">)</span>
        <span class="n">f1_2_start</span><span class="p">,</span> <span class="n">f1_2_end</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">loc_f1_2</span><span class="p">)</span>

        <span class="n">overlap_diff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment1</span><span class="p">[</span><span class="n">f1_1_start</span><span class="p">:</span><span class="n">f1_2_end</span><span class="p">])</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">fragment2</span><span class="p">[</span><span class="n">f2_1_start</span><span class="p">:</span><span class="n">f2_2_end</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">overlap_diff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Overlap is 0&quot;</span>

        <span class="k">if</span> <span class="n">overlap_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_loc_f1_1</span> <span class="o">=</span> <span class="n">create_location</span><span class="p">(</span>
                <span class="n">f1_1_start</span><span class="p">,</span> <span class="n">f1_2_start</span> <span class="o">-</span> <span class="n">overlap_diff</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">new_loc_f2_1</span> <span class="o">=</span> <span class="n">create_location</span><span class="p">(</span><span class="n">f2_1_start</span><span class="p">,</span> <span class="n">f2_2_start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_loc_f2_1</span> <span class="o">=</span> <span class="n">create_location</span><span class="p">(</span>
                <span class="n">f2_1_start</span><span class="p">,</span> <span class="n">f2_2_start</span> <span class="o">+</span> <span class="n">overlap_diff</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment2</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">new_loc_f1_1</span> <span class="o">=</span> <span class="n">create_location</span><span class="p">(</span><span class="n">f1_1_start</span><span class="p">,</span> <span class="n">f1_2_start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment1</span><span class="p">))</span>

        <span class="n">new_assembly</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">new_loc_f1_1</span><span class="p">,</span> <span class="n">new_loc_f2_1</span><span class="p">),</span>
            <span class="n">new_assembly</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">new_assembly</span></div>


<div class="viewcode-block" id="Assembly.get_insertion_assemblies">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.get_insertion_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_insertion_assemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemblies that represent the insertion of a fragment or series of fragment inside a linear construct. For instance,</span>
<span class="sd">        digesting CCCCGAATTCCCCGAATTC with EcoRI and inserting the fragment with two overhangs into the EcoRI site of AAAGAATTCAAA.</span>
<span class="sd">        This is not so much meant for the use-case of linear fragments that represent actual linear fragments, but for linear</span>
<span class="sd">        fragments that represent a genome region. This can then be used to simulate homologous recombination.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">only_adjacent_edges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;only_adjacent_edges not implemented for insertion assemblies&quot;</span>
            <span class="p">)</span>

        <span class="n">cycles</span> <span class="o">=</span> <span class="n">limit_iterator</span><span class="p">(</span><span class="n">_nx</span><span class="o">.</span><span class="n">cycles</span><span class="o">.</span><span class="n">simple_cycles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">),</span> <span class="mi">10000</span><span class="p">)</span>

        <span class="c1"># We apply constrains already here because sometimes the combinatorial explosion is too large</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">:</span>
            <span class="n">cycles</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cycles</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)]</span>

        <span class="c1"># Remove cycles with duplicates</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cycles</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">c</span><span class="p">)))]</span>

        <span class="n">possible_assembly_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_possible_assembly_number</span><span class="p">(</span>
            <span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cycles</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">possible_assembly_number</span> <span class="o">&gt;</span> <span class="n">max_assemblies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Too many assemblies (</span><span class="si">{</span><span class="n">possible_assembly_number</span><span class="si">}</span><span class="s2"> pre-validation) to assemble&quot;</span>
            <span class="p">)</span>

        <span class="c1"># We find cycles first</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="n">limit_iterator</span><span class="p">(</span><span class="n">_nx</span><span class="o">.</span><span class="n">cycles</span><span class="o">.</span><span class="n">simple_cycles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">),</span> <span class="mi">10000</span><span class="p">)</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_path2assembly_list</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">iterator</span><span class="p">),</span> <span class="p">[]</span>
        <span class="p">)</span>
        <span class="c1"># We format the edge case</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">format_insertion_assembly_edge_case</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span><span class="p">]</span>
        <span class="c1"># We select those that contain exactly only one suitable edge</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">b</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_insertion_assembly</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="c1"># First fragment should be in the + orientation</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">assemblies</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_is_valid</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">,</span> <span class="n">is_insertion</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Assembly.assemble_linear">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.assemble_linear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_linear</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble linear constructs, from assemblies returned by self.get_linear_assemblies.&quot;&quot;&quot;</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linear_assemblies</span><span class="p">(</span><span class="n">only_adjacent_edges</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assembly.assemble_circular">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.assemble_circular">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_circular</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble circular constructs, from assemblies returned by self.get_circular_assemblies.&quot;&quot;&quot;</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circular_assemblies</span><span class="p">(</span><span class="n">only_adjacent_edges</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assembly.assemble_insertion">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.assemble_insertion">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_insertion</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble insertion constructs, from assemblies returned by self.get_insertion_assemblies.&quot;&quot;&quot;</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_insertion_assemblies</span><span class="p">(</span><span class="n">only_adjacent_edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">is_insertion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assembly.get_locations_on_fragments">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.get_locations_on_fragments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_locations_on_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Location</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a dictionary where the keys are the nodes in the graph, and the values are dictionaries with keys</span>
<span class="sd">        `left`, `right`, containing (for each fragment) the locations where the fragment is joined to another fragment on its left</span>
<span class="sd">        and right side. The values in `left` and `right` are often the same, except in restriction-ligation with partial overlap enabled,</span>
<span class="sd">        where we can end up with a situation like this:</span>

<span class="sd">        GGTCTCCCCAATT and aGGTCTCCAACCAA as fragments</span>

<span class="sd">        # Partial overlap in assembly 1[9:11]:2[8:10]</span>
<span class="sd">        GGTCTCCxxAACCAA</span>
<span class="sd">        CCAGAGGGGTTxxTT</span>

<span class="sd">        # Partial overlap in 2[10:12]:1[7:9]</span>
<span class="sd">        aGGTCTCCxxCCAATT</span>
<span class="sd">        tCCAGAGGTTGGxxAA</span>

<span class="sd">        Would return</span>
<span class="sd">        {</span>
<span class="sd">            1: {&#39;left&#39;: [7:9], &#39;right&#39;: [9:11]},</span>
<span class="sd">            2: {&#39;left&#39;: [8:10], &#39;right&#39;: [10:12]},</span>
<span class="sd">            -1: {&#39;left&#39;: [2:4], &#39;right&#39;: [4:6]},</span>
<span class="sd">            -2: {&#39;left&#39;: [2:4], &#39;right&#39;: [4:6]}</span>
<span class="sd">        }</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">locations_on_fragments</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">this_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(),</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">()}</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                        <span class="n">edge_location</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;locations&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">edge_location</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">this_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                            <span class="n">this_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_location</span><span class="p">)</span>
            <span class="n">this_dict</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">this_dict</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">this_dict</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">this_dict</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_dict</span>

        <span class="k">return</span> <span class="n">locations_on_fragments</span></div>


<div class="viewcode-block" id="Assembly.assembly_uses_only_adjacent_edges">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.Assembly.assembly_uses_only_adjacent_edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assembly_uses_only_adjacent_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assembly</span><span class="p">,</span> <span class="n">is_circular</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether only adjacent edges within each fragment are used in the assembly. This is useful to check if a cut and ligate assembly is valid,</span>
<span class="sd">        and prevent including partially digested fragments. For example, imagine the following fragment being an input for a digestion</span>
<span class="sd">        and ligation assembly, where the enzyme cuts at the sites indicated by the vertical lines:</span>

<span class="sd">        ```</span>
<span class="sd">                 x       y       z</span>
<span class="sd">          -------|-------|-------|---------</span>
<span class="sd">        ```</span>

<span class="sd">        We would only want assemblies that contain subfragments start-x, x-y, y-z, z-end, and not start-x, y-end, for instance.</span>
<span class="sd">        The latter would indicate that the fragment was partially digested.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">locations_on_fragments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locations_on_fragments</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">locations_on_fragments</span><span class="p">:</span>
            <span class="n">fragment_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">]:</span>
                <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">side</span><span class="p">]</span> <span class="o">=</span> <span class="n">gather_overlapping_locations</span><span class="p">(</span>
                    <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">side</span><span class="p">],</span> <span class="n">fragment_len</span>
                <span class="p">)</span>

        <span class="n">allowed_location_pairs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">locations_on_fragments</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_circular</span><span class="p">:</span>
                <span class="c1"># We add the existing ends of the fragment</span>
                <span class="n">left</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,)]</span> <span class="o">+</span> <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">]</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,)]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># For circular assemblies, we add the first location at the end</span>
                <span class="c1"># to allow for the last edge to be used</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">]</span>
                <span class="n">right</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="o">+</span> <span class="n">locations_on_fragments</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">][:</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
                <span class="n">pairs</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">pair</span><span class="p">))</span>
            <span class="n">allowed_location_pairs</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">pairs</span>

        <span class="n">fragment_assembly</span> <span class="o">=</span> <span class="n">edge_representation2subfragment_representation</span><span class="p">(</span>
            <span class="n">assembly</span><span class="p">,</span> <span class="n">is_circular</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span> <span class="ow">in</span> <span class="n">fragment_assembly</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start_location</span><span class="p">,</span> <span class="n">end_location</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_location_pairs</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># https://pyformat.info</span>
        <span class="k">return</span> <span class="n">_pretty_str</span><span class="p">(</span>
            <span class="s2">&quot;Assembly</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;fragments..: </span><span class="si">{sequences}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;limit(bp)..: </span><span class="si">{limit}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;G.nodes....: </span><span class="si">{nodes}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;algorithm..: </span><span class="si">{al}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">sequences</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">bp&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">),</span>
                <span class="n">limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">,</span>
                <span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span>
                <span class="n">al</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="PCRAssembly">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.PCRAssembly">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PCRAssembly</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An assembly that represents a PCR, where `fragments` is a list of primer, template, primer (in that order).</span>
<span class="sd">    It always uses the `primer_template_overlap` algorithm and accepts the `mismatches` argument to indicate</span>
<span class="sd">    the number of mismatches allowed in the overlap. Only supports substitution mismatches, not indels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_Dseqrecord</span> <span class="o">|</span> <span class="n">_Primer</span><span class="p">],</span> <span class="n">limit</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">mismatches</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="n">value_error</span> <span class="o">=</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;PCRAssembly assembly must be initialised with a list/tuple of primer, template, primer&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">value_error</span>

        <span class="c1"># Validate the inputs: should be a series of primer, template, primer</span>
        <span class="n">wrong_fragment_class</span> <span class="o">=</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_Primer</span><span class="p">),</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_Primer</span><span class="p">),</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">_Primer</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">wrong_fragment_class</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">value_error</span>

        <span class="c1"># TODO: allow for the same fragment to be included more than once?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
        <span class="c1"># Add positive and negative nodes for forward and reverse fragments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;seq&quot;</span><span class="p">:</span> <span class="n">f</span><span class="p">})</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frags</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span>
            <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;seq&quot;</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()})</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">primer_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">),</span> <span class="mi">3</span><span class="p">):</span>
            <span class="c1"># primer, template, primer</span>
            <span class="n">p1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">primer_ids</span> <span class="o">+=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>
            <span class="n">pairs</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">],</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="p">]))</span>
            <span class="n">pairs</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">p1</span><span class="p">,</span> <span class="o">-</span><span class="n">p2</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="n">u_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s2">&quot;seq&quot;</span><span class="p">]</span>
            <span class="n">v_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s2">&quot;seq&quot;</span><span class="p">]</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">primer_template_overlap</span><span class="p">(</span><span class="n">u_seq</span><span class="p">,</span> <span class="n">v_seq</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">mismatches</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from_match</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u_seq</span><span class="p">,</span> <span class="n">v_seq</span><span class="p">)</span>

        <span class="c1"># These two are constrained</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_fragment_order</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">frags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="n">primer_template_overlap</span>

        <span class="k">return</span>

<div class="viewcode-block" id="PCRAssembly.get_linear_assemblies">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.PCRAssembly.get_linear_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_assemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">only_adjacent_edges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;only_adjacent_edges not implemented for PCR assemblies&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_linear_assemblies</span><span class="p">(</span><span class="n">max_assemblies</span><span class="o">=</span><span class="n">max_assemblies</span><span class="p">)</span></div>


<div class="viewcode-block" id="PCRAssembly.get_circular_assemblies">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.PCRAssembly.get_circular_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_circular_assemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;get_circular_assemblies not implemented for PCR assemblies&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PCRAssembly.get_insertion_assemblies">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.PCRAssembly.get_insertion_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_insertion_assemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;get_insertion_assemblies not implemented for PCR assemblies&quot;</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SingleFragmentAssembly">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.SingleFragmentAssembly">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SingleFragmentAssembly</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An assembly that represents the circularisation or splicing of a single fragment.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frags</span><span class="p">:</span> <span class="p">[</span><span class="n">_Dseqrecord</span><span class="p">],</span> <span class="n">limit</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">common_sub_strings</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;SingleFragmentAssembly assembly must be initialised with a single fragment&quot;</span>
            <span class="p">)</span>
        <span class="c1"># TODO: allow for the same fragment to be included more than once?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
        <span class="n">frag</span> <span class="o">=</span> <span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Add positive and negative nodes for forward and reverse fragments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">seq</span><span class="o">=</span><span class="n">frag</span><span class="p">)</span>

        <span class="n">matches</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from_match</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="n">frag</span><span class="p">)</span>

        <span class="c1"># To avoid duplicated outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])</span>

        <span class="c1"># These two are constrained</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_fragment_order</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">frags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="n">algorithm</span>

        <span class="k">return</span>

<div class="viewcode-block" id="SingleFragmentAssembly.get_circular_assemblies">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.SingleFragmentAssembly.get_circular_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_circular_assemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
        <span class="c1"># We don&#39;t want the same location twice</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_circular_assemblies</span><span class="p">(</span><span class="n">only_adjacent_edges</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="SingleFragmentAssembly.get_insertion_assemblies">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.SingleFragmentAssembly.get_insertion_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_insertion_assemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">only_adjacent_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_assemblies</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeRepresentationAssembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This could be renamed splicing assembly, but the essence is similar&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">only_adjacent_edges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;only_adjacent_edges not implemented for insertion assemblies&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">splicing_assembly_filter</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c1"># We don&#39;t want the same location twice</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># We don&#39;t want to get overlap only (e.g. GAATTCcatGAATTC giving GAATTC)</span>
            <span class="n">left_start</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">right_end</span> <span class="o">=</span> <span class="n">_location_boundaries</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">left_start</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">right_end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># We don&#39;t want the same location twice</span>
        <span class="n">assemblies</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="n">splicing_assembly_filter</span><span class="p">,</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_insertion_assemblies</span><span class="p">(</span><span class="n">max_assemblies</span><span class="o">=</span><span class="n">max_assemblies</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblies</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembly_is_valid</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_all_fragments</span><span class="p">,</span> <span class="n">is_insertion</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="SingleFragmentAssembly.get_linear_assemblies">
<a class="viewcode-back" href="../../modules/pydna_assembly2.html#pydna.assembly2.SingleFragmentAssembly.get_linear_assemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_assemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Linear assembly does not make sense&quot;</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Björn F. Johansson.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>